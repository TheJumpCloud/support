[
  {
    "name": "Linux - Disable Local User | v1.0 JCCG",
    "type": "linux",
    "command": "#!/bin/sh\n################################################################################\n# This script will disable the *matched* username patterns in the usersToMatch\n# list variable. For Example:\n# Users on the system: administrator, steve, it-staff\n# export usersToMatch=\"admin it\"\n# both the administrator and it-staff would be disabled\n# - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -\n# Test how this command will run by setting the disable variable to false. When\n# set to false the script will identify users to disable and print out a list\n# without disabling the accounts\n################################################################################\n\n# Settings, set true or false\ndisable=true\n\n# Enter user(s) patterns you want to match against (user admin bobsAccount)\nexport usersToMatch=\"admin it\"\n\n# Do not modify below this line\n################################################################################\n# last item in matched user list\nLAST_ITEM=\"${usersToMatch##* }\"\n# regexMatchregexPattern\nregexPattern=\"\"\n\nfor user in $usersToMatch; do\n    echo \"adding $user to regex pattern\"\n    if [ \"$user\" = \"$LAST_ITEM\" ]; then\n        regexPattern=\"${regexPattern:+${regexPattern}}${user}[^\\s]*\"\n    else\n        regexPattern=\"${regexPattern:+${regexPattern}}${user}[^\\s]*|\"\n    fi\ndone\n\necho \"Searching System for the following users: $usersToMatch\"\necho \"Regex Pattern: $regexPattern\"\n\n# Get usernames on system:\nallUsers=$(cut -d : -f 1 /etc/passwd)\n\nfoundUsers=\"\"\nfor value in $allUsers; do\n    if echo \"$value\" | grep -iqE \"$regexPattern\"; then\n        echo \"found user $value on system\"\n        foundUsers=\"${foundUsers:+${foundUsers}}${value} \"\n    fi\ndone\nloggedInUsers=$(who -u)\nfor user in $foundUsers; do\n    echo \"Disabling $user's login shell...\"\n    # echo \"testing for $user in $loggedInUsers\"\n    if [ $disable = true ]; then\n        if echo \"$loggedInUsers\" | grep -iqE \"$user\"; then\n            echo \"logging $user out of system\"\n            pkill -KILL -u \"${user}\"\n        fi\n        # Expire the user's password\n        sudo usermod --expiredate 1 $user\n        # Remove the user from the login screen\n        printf \"[User]\\nSystemAccount=true\\n\" | sudo tee /var/lib/AccountsService/users/$user\n        sudo systemctl restart accounts-daemon.service\n    fi\ndone",
    "link": "https://github.com/TheJumpCloud/support/blob/master/PowerShell/JumpCloud%20Commands%20Gallery/Linux%20Commands/Linux%20-%20Disable%20Local%20User.md",
    "description": "This command will disable the local users that match the regex pattern supplied in the 'usersToMatch' list variable. If for example, a system contains the following users:\n\nSteve, Administrator, IT-Admin\n\nAnd the usersToMatch variable is set to (admin it), both the 'Administrator' and 'IT-Admin' Account would be disabled. The Regex pattern searches usernames for partial matches.\n\nRun this script with disable=false to test what accounts would be disabled before running disable=true."
  },
  {
    "name": "Linux - Install Sentinel One | v1.0 JCCG",
    "type": "linux",
    "command": "#!/bin/bash\n###################################################\nsentinelToken=\"YOURTOKEN\"\nfilename=\"sentineloneagent.deb\"\nDownloadURL=\"https://path/to/url.deb\"\n###################################################\n\n\ncurl -o $filename $DownloadURL\n\napt install ./$filename -y\n\nif [ -f /opt/sentinelone/bin/sentinelctl ]; then\n    echo \"/opt/sentinelone/bin/sentinelctl found!\"\n    /opt/sentinelone/bin/sentinelctl management token set $sentinelToken\n    /opt/sentinelone/bin/sentinelctl control start\nelse\n    echo \"/opt/sentinelone/bin/sentinelctl not found!\"\n    exit 1\nfi",
    "link": "https://github.com/TheJumpCloud/support/blob/master/PowerShell/JumpCloud%20Commands%20Gallery/Linux%20Commands/Linux%20-%20Install%20Sentinel%20One.md",
    "description": "Install Sentinel One agent"
  },
  {
    "name": "Linux - Install Snap Daemon | v1.0 JCCG",
    "type": "linux",
    "command": "apt install snapd",
    "link": "https://github.com/TheJumpCloud/support/blob/master/PowerShell/JumpCloud%20Commands%20Gallery/Linux%20Commands/Linux%20-%20Snap%20-%20Install%20Snap%20Daemon.md",
    "description": "Installs the Snap daemon required to manage applications with Snap. To complete the installation, either logout and login or restart the system. To learn more about Snap, visit [SnapCraft's website](https://snapcraft.io/)"
  },
  {
    "name": "Linux - List All Users | v1.0 JCCG",
    "type": "linux",
    "command": "awk -F'[/:]' '{if ($3 >= 1000 && $3 != 65534) print $1}' /etc/passwd",
    "link": "https://github.com/TheJumpCloud/support/blob/master/PowerShell/JumpCloud%20Commands%20Gallery/Linux%20Commands/Linux%20-%20List%20All%20Users.md",
    "description": "Lists all users on a Linux system"
  },
  {
    "name": "Linux - List Available Updates | v1.0 JCCG",
    "type": "linux",
    "command": "apt-get -u upgrade --assume-no",
    "link": "https://github.com/TheJumpCloud/support/blob/master/PowerShell/JumpCloud%20Commands%20Gallery/Linux%20Commands/Linux%20-%20List%20Avaliable%20Updates.md",
    "description": "Shows available updates on a Linux system. The '-assume-no' parameter is used to prevent the installation of any updates."
  },
  {
    "name": "Linux - Pull jcagent.log | v1.0 JCCG",
    "type": "linux",
    "command": "cat /var/log/jcagent.log",
    "link": "https://github.com/TheJumpCloud/support/blob/master/PowerShell/JumpCloud%20Commands%20Gallery/Linux%20Commands/Linux%20-%20Pull%20jcagent.log.md",
    "description": "Pulls the JC agent log from a Linux system. If the jcagent.log is larger than 1 MB the most recend 1 MB of data from the log will be returned."
  },
  {
    "name": "Linux - Rename System HostName from JumpCloud | v2.0 JCCG",
    "type": "linux",
    "command": "#!/bin/bash\n################################################################################\n# This script will update the system hostname to\n# match the value of this systems displayName in the JumpCloud console.\n# An API Key with read access is required to run this script.\n################################################################################\n\n# Set Read API KEY - Required to read \"DisplayName\" from console.jumpcloud.com\nAPI_KEY=\"yourReadWriteAPIKey\"\n\n# ------- Do not modify below this line ------\n\n# Exit immediately on error\nset -e\n# Functions\nfunction validateVariable() {\n    var=$1\n    if [[ -z \"$var\" ]]; then\n        echo \"Required variable was null, exiting...\"\n        exit 1\n    else\n        echo \"Variable is set to '$var'\"\n    fi\n} >&2\n# Get System Key\nfunction getSystemKey() {\n    conf=\"$(cat /opt/jc/jcagent.conf)\"\n    regex='\\\"systemKey\\\":\\\"[a-zA-Z0-9]{24}\\\"'\n    if [[ $conf =~ $regex ]]; then\n        systemKey=\"${BASH_REMATCH[@]}\"\n    fi\n    # echo \"$(date \"+%Y-%m-%dT%H:%M:%S\"): systemKey = $systemKey \"\n    regex='[a-zA-Z0-9]{24}'\n    if [[ $systemKey =~ $regex ]]; then\n        systemID=\"${BASH_REMATCH[@]}\"\n    fi\n    # echo \"$(date \"+%Y-%m-%dT%H:%M:%S\"): systemID = $systemID \"\n    echo \"$systemID\"\n}\nsystemID=$(getSystemKey)\nsearch=$(\n    curl -f -X GET https://console.jumpcloud.com/api/systems/${systemID} \\\n        -H 'Accept: application/json' \\\n        -H 'Content-Type: application/json' \\\n        -H \"x-api-key: ${API_KEY}\"\n)\n# regex pattern to search displayNames. This pattern selects the text after \"displayName\":\" and before \",\nregex='(\"displayName\":\")([^\"]*)(\",)'\nif [[ $search =~ $regex ]]; then\n    new_hostname=\"${BASH_REMATCH[2]}\"\nfi\n\nold_hostname=$( cat /etc/hostname )\nhostnamectl set-hostname $new_hostname\nsed -i -e \"s/$old_hostname/$new_hostname/g\" /etc/hosts\n\necho \"$old_hostname was renamed to $new_hostname\"\n\nexit 0",
    "link": "https://github.com/TheJumpCloud/support/blob/master/PowerShell/JumpCloud%20Commands%20Gallery/Linux%20Commands/Linux%20-%20Rename%20System%20HostName%20from%20JumpCloud.md",
    "description": "This script uses a read only API key to gather info about the current system. Using Regex, the code filters out the displayName of a given system and sets the system HostName to the name set in the JumpCloud console."
  },
  {
    "name": "Linux - Set Agent Log Level to Debug | v1.0 JCCG",
    "type": "linux",
    "command": "#!/bin/bash\n\n# Check for at command, necessary to schedule the command later\ndpkg -l \"at\" > /dev/null 2>&1\nif [ $? = '1' ]; then\n    echo \"at command could not be found, please install 'at' package\"\n    exit 1\nfi\n\nscriptFile=\"/var/tmp/jc_setAgent.sh\"\n\n# build the script\ncat <<'EOF' > $scriptFile\n#!/bin/bash\n\n# Set Debug Level | Either \"DEBUG\" or \"TRACE\"\nsetLevel=\"DEBUG\"\n\n# File Locations\nlogLevelFile=\"/opt/jc/loglevel.cache\"\nscriptFile=\"/var/tmp/jc_setAgent.sh\"\n\n# Call LogLevel Function to set log level\nif [ ! -f \"$logLevelFile\" ]; then\nprintf DEBUG > $logLevelFile\nfi\n\n# Restart Agent to start logging with new level\nservice jcagent restart\n\n# Remove this script\nrm -- \"$0\"\nEOF\necho \"Setting JumpCloud-Agent Log Level settings\"\nat now + 1 minutes -f $scriptFile\n\nexit 0",
    "link": "https://github.com/TheJumpCloud/support/blob/master/PowerShell/JumpCloud%20Commands%20Gallery/Linux%20Commands/Linux%20-%20Set%20Agent%20Log%20Level%20to%20Debug.md",
    "description": "This command will set the JumpCloud Agent Log Level to Debug level."
  },
  {
    "name": "Linux - Set Agent Log Level to Default | v1.0 JCCG",
    "type": "linux",
    "command": "#!/bin/bash\n\n# Check for at command, necessary to schedule the command later\ndpkg -l \"at\" > /dev/null 2>&1\nif [ $? = '1' ]; then\n    echo \"at command could not be found, please install 'at' package\"\n    exit 1\nfi\n\nscriptFile=\"/var/tmp/jc_setAgent.sh\"\n\n# build the script\ncat <<'EOF' > $scriptFile\n#!/bin/bash\n\n# Set Debug Level | Either \"DEBUG\" or \"TRACE\"\nsetLevel=\"DEBUG\"\n\n# File Locations\nlogLevelFile=\"/opt/jc/loglevel.cache\"\nscriptFile=\"/var/tmp/jc_setAgent.sh\"\n\n# Call LogLevel Function to set log level\nif [ -f \"$logLevelFile\" ]; then\nrm $logLevelFile\nfi\n\n# Restart Agent to start logging with new level\nservice jcagent restart\n\n# Remove this script\nrm -- \"$0\"\nEOF\n\necho \"Setting JumpCloud-Agent Log Level to default settings\"\nat now + 1 minutes -f $scriptFile\n\nexit 0",
    "link": "https://github.com/TheJumpCloud/support/blob/master/PowerShell/JumpCloud%20Commands%20Gallery/Linux%20Commands/Linux%20-%20Set%20Agent%20Log%20Level%20to%20Default.md",
    "description": "This command will set the JumpCloud Agent Log Level to Default logging level."
  },
  {
    "name": "Linux - Snap - Install Microsoft VS Code | v1.0 JCCG",
    "type": "linux",
    "command": "snap install code --classic",
    "link": "https://github.com/TheJumpCloud/support/blob/master/PowerShell/JumpCloud%20Commands%20Gallery/Linux%20Commands/Linux%20-%20Snap%20-%20Install%20Microsoft%20VS%20Code.md",
    "description": "Install Microsoft VS Code app with the Snap app manager. To learn more about Snap, visit [SnapCraft's website](https://snapcraft.io/)"
  },
  {
    "name": "Linux - Snap - Install Slack | v1.0 JCCG",
    "type": "linux",
    "command": "snap install slack --classic",
    "link": "https://github.com/TheJumpCloud/support/blob/master/PowerShell/JumpCloud%20Commands%20Gallery/Linux%20Commands/Linux%20-%20Snap%20-%20Install%20Slack.md",
    "description": "Install Slack app with the Snap app manager. To learn more about Snap, visit [SnapCraft's website](https://snapcraft.io/)"
  },
  {
    "name": "Linux - Snap - Remove Slack | v1.0 JCCG",
    "type": "linux",
    "command": "snap remove slack",
    "link": "https://github.com/TheJumpCloud/support/blob/master/PowerShell/JumpCloud%20Commands%20Gallery/Linux%20Commands/Linux%20-%20Snap%20-%20Remove%20Slack.md",
    "description": "Remove Slack app with the Snap app manager. To learn more about Snap, visit [SnapCraft's website](https://snapcraft.io/)"
  },
  {
    "name": "Linux - remote-assist - Disable wayland windowing system | v1.0 JCCG",
    "type": "linux",
    "command": "#!/bin/bash\n################################################################################\n# This script will disable wayland windowing system\n################################################################################\n\nif [[ \"${UID}\" != 0 ]]; then\n    (>&2 echo \"Error:  $0 must be run as root\")\n    exit 1\nfi\n\ndisable_wayland() {\n    case ${linuxType} in\n        ubuntu|\\\"rocky\\\"|\\\"centos\\\")\n            `sed -i 's/^#.*WaylandEnable=.*/WaylandEnable=false/' /etc/gdm3/custom.conf`\n            ;;\n        debian)\n            `sed -i 's/^#.*WaylandEnable=.*/WaylandEnable=false/' /etc/gdm3/daemon.conf`\n            ;;\n    esac\n}\n\n# Get the current windowing system\nwindowingSystem=$(echo $XDG_SESSION_TYPE)\nif [ \"$windowingSystem\" == \"\" ]; then\n    windowingSystem=`loginctl show-session $(awk '/tty/ {print $1}' <(loginctl)) -p Type | awk -F= '{print $2}'`\nfi\n\nwindowingSystem=\"wayland\"\n\n# Get the linux type\nlinuxType=`awk -F= '$1==\"ID\" { print $2 ;}' /etc/os-release`\nlinuxType=\"$(echo -e \"${linuxType}\" | sed -e 's/^[[:space:]]*//')\"\n\nif [[ \"$linuxType\" == \"linuxmint\" ]]; then\n    echo \"Linuxmint does not support wayland. Nothing to be done for linuxmint.\"\n    exit 0\nfi\n\nif [[ \"$windowingSystem\" == \"wayland\" ]]; then\n    disable_wayland \"$linuxType\"\nelif [[ \"$windowingSystem\" == \"x11\" ]]; then\n    echo \"Windowing System is already set to x11\"\n    exit 1\nfi\n\necho \"Now 'restart' the machine or run 'sudo systemctl restart gdm'.\"\n\nexit 0",
    "link": "https://github.com/TheJumpCloud/support/blob/master/PowerShell/JumpCloud%20Commands%20Gallery/Linux%20Commands/Linux%20-%20remote-assist%20-%20Disable%20wayland%20windowing%20system.md",
    "description": "This script enables the Wayland windowing system on the Linux machine."
  },
  {
    "name": "Linux - remote-assist - Enable wayland windowing system | v1.0 JCCG",
    "type": "linux",
    "command": "#!/bin/bash\n################################################################################\n# This script will enable wayland windowing system\n################################################################################\n\nif [[ \"${UID}\" != 0 ]]; then\n    (>&2 echo \"Error:  $0 must be run as root\")\n    exit 1\nfi\n\nenable_wayland() {\n    case ${linuxType} in\n        ubuntu|\\\"rocky\\\"|\\\"centos\\\")\n            `sed -i 's/WaylandEnable=.*/#WaylandEnable=false/' /etc/gdm3/custom.conf`\n            ;;\n        debian)\n            `sed -i 's/WaylandEnable=.*/#WaylandEnable=false/' /etc/gdm3/daemon.conf`\n            ;;\n    esac\n}\n\n# Get the current windowing system\nwindowingSystem=$(echo $XDG_SESSION_TYPE)\nif [[ \"$windowingSystem\" == \"\" ]]; then\n    windowingSystem=`loginctl show-session $(awk '/tty/ {print $1}' <(loginctl)) -p Type | awk -F= '{print $2}'`\nfi\n\n# Get the linux type\nlinuxType=`awk -F= '$1==\"ID\" { print $2 ;}' /etc/os-release`\nlinuxType=\"$(echo -e \"${linuxType}\" | sed -e 's/^[[:space:]]*//')\"\n\nif [[ \"$linuxType\" == \"linuxmint\" ]]; then\n    echo \"Linuxmint does not support wayland. Nothing to be done for linuxmint.\"\n    exit 0\nfi\n\nif [[ \"$windowingSystem\" == \"wayland\" ]]; then\n    echo \"Windowing System is already set to wayland\"\n    exit 1\nelif [[ \"$windowingSystem\" == \"x11\" ]]; then\n    enable_wayland \"$linuxType\"\nfi\n\necho \"Next step is to either 'reboot' the machine or run 'sudo systemctl restart gdm'.\"\n\nexit 0",
    "link": "https://github.com/TheJumpCloud/support/blob/master/PowerShell/JumpCloud%20Commands%20Gallery/Linux%20Commands/Linux%20-%20remote-assist%20-%20Enable%20wayland%20windowing%20system.md",
    "description": "This script enables the Wayland windowing system on the Linux machine."
  },
  {
    "name": "Linux - remote-assist - Installation script | v1.0 JCCG",
    "type": "linux",
    "command": "#!/usr/bin/env bash\n################################################################################\n# This script will install remote assist application on a Linux device\n################################################################################\n\n# Disable following external sources\n# shellcheck disable=SC1091,SC1090,SC2059\n\nif [[ \"${UID}\" != 0 ]]; then\n    (>&2 echo \"Error: $0 must be run as root\")\n    exit 1\nfi\n\nset -u\n\n# set the RAA version string in the below variable before running the script.\n# the example format of version: v0.75.0\ndeclare -t raa_version=\"\"\n\nif [[ \"$raa_version\" == \"\" ]]; then\n    echo \"'raa_version' need to be provided in the script (eg. v0.75.0)\"\n    exit 0\nfi\n\ntmp_dir=$(mktemp -d)\n\ndeclare -r timeout=900\ndeclare -r max_retries=4\ndeclare -r max_retry_time=3600\n\ndeclare -r tmp_dir\n\ndeclare -r pub_key_name=\"jumpcloud-remote-assist-agent.gpg.asc\"\ndeclare -r raa_binary_name=\"jumpcloud-remote-assist\"\n\ndeclare -r install_prefix=\"/opt/jc_user_ro\"\ndeclare -r apps_path=\"/usr/share/applications\"\ndeclare -r raa_directory=\"${install_prefix}/jumpcloud-remote-assist\"\ndeclare -r raa_desktop_file=\"${raa_directory}/resources/build-app/linux/jumpcloud-remote-assist.desktop\"\ndeclare -r uninstaller_path=\"${install_prefix}/bin/uninstall-${raa_binary_name}\"\n\ndeclare -r remote_pub_key_url=\"https://jumpcloud-windows-agent.s3.amazonaws.com/production/remote-assist/jumpcloud-remote-assist-agent.gpg.asc\"\ndeclare -r remote_tgz_url=\"https://jumpcloud-windows-agent.s3.amazonaws.com/production/remote-assist/versions/${raa_version}/jumpcloud-remote-assist-agent_x86_64.tar.gz\"\n\ndeclare -r old_pub_key_fingerprint=\"83463C47A34D1BC1\"\ndeclare -r pub_key_fingerprint=\"8C31C1376B37D307\"\ndeclare -r owner_trust=\"C2122200660347DB094054808C31C1376B37D307:6:\"\ndeclare -r tgz_name=\"jumpcloud-remote-assist-agent.tar.gz\"\ndeclare -r sig_name=\"${tgz_name}.zig\"\n\ndeclare -r local_pub_key_path=\"${tmp_dir}/${pub_key_name}\"\ndeclare -r local_tgz_tmp_path=\"${tmp_dir}/${tgz_name}\"\ndeclare -r local_sig_tmp_path=\"${tmp_dir}/${sig_name}\"\n\ndeclare -r remote_sig_url=\"${remote_tgz_url}.sig\"\n\nfunction cleanup() {\n  rm -rf \"${tmp_dir}\"\n}\n\nfunction download_single_file() {\n  local url=${1}\n  local local_file=${2}\n\n  echo \"Downloading ${url}\"\n\n  curl_output=$(curl -v --trace-time \\\n    --max-time \"${timeout}\" --retry \"${max_retries}\" \\\n    --retry-max-time \"${max_retry_time}\" \\\n    --output \"${local_file}\" \"${url}\" -C - 2>&1)\n\n  rc=$?\n  if [[ \"$rc\" != \"0\" ]]; then\n    echo \"Failed to download ${url}\"\n    echo \"${curl_output}\"\n    exit ${rc}\n  fi\n}\n\nfunction remove_old_pub_key() {\n  if gpg --list-keys | grep -q \"${old_pub_key_fingerprint}\"; then\n    echo \"Removing old public key ${old_pub_key_fingerprint}\"\n    gpg  --batch --yes --delete-key \"${old_pub_key_fingerprint}\"\n  fi\n}\n\nfunction install_pub_key() {\n  remove_old_pub_key\n\n  output=$(gpg --list-keys | grep \"${pub_key_fingerprint}\")\n  if [[ \"${output}\" == \"\" ]]; then\n    download_single_file \"${remote_pub_key_url}\" \"${local_pub_key_path}\"\n    echo \"Importing public key ${pub_key_fingerprint}\"\n    gpg --import \"${local_pub_key_path}\"\n    echo \"${owner_trust}\" | gpg --import-ownertrust\n  fi\n}\n\nfunction verify_signature() {\n  local sig=\"${1}\"\n  local tgz=\"${2}\"\n  gpg --verify \"${sig}\" \"${tgz}\" 2>&1\n}\n\nfunction download_files() {\n  download_single_file \"${remote_tgz_url}\" \"${local_tgz_tmp_path}\"\n  download_single_file \"${remote_sig_url}\" \"${local_sig_tmp_path}\"\n  if ! verify_signature \"${local_sig_tmp_path}\" \"${local_tgz_tmp_path}\"; then\n    echo \"Unable to verify signature for ${tgz_name}\"\n    exit 1\n  fi\n}\n\nfunction uncompress_tarball() {\n  echo \"Installing new RAA\"\n  mkdir -p \"${install_prefix}\"\n  chmod 755 \"${install_prefix}\"\n  tar zxf \"${local_tgz_tmp_path}\" -C \"${install_prefix}\"\n}\n\nfunction remove_old_raa_dir() {\n  if [[ -d \"${raa_directory}\" ]]; then\n    echo \"Removing old RAA\"\n    rm -rf \"${raa_directory}\"\n  fi\n}\n\nfunction kill_running_raa_instance() {\n  local pid_list\n  pid_list=$(pidof \"${raa_binary_name}\")\n  for raa_pid in ${pid_list}; do\n    echo \"Stopping remote assist process ${raa_pid}\"\n    kill \"${raa_pid}\"\n  done\n}\n\nfunction install_new_raa() {\n  remove_old_raa_dir\n  uncompress_tarball\n}\n\nfunction install_desktop_file() {\n  echo \"Installing desktop shortcut\"\n  if [[ -d \"${apps_path}\" ]]; then\n    cp \"${raa_desktop_file}\" \"${apps_path}\"\n    if command -v \"update-desktop-database\" &>/dev/null; then\n      update-desktop-database\n    fi\n  fi\n}\n\nfunction install_uninstall_script() {\n  mkdir -p \"$(dirname \"${uninstaller_path}\")\"\n  cat > \"${uninstaller_path}\" <<'EOF'\n{{template \"linuxUninstall.tmpl.sh\" .}}\nEOF\n  chmod -x \"${uninstaller_path}\"\n  chmod 700 \"${uninstaller_path}\"\n}\n\nfunction main() {\n  trap cleanup EXIT\n  install_pub_key\n  download_files\n  kill_running_raa_instance\n  install_new_raa\n  install_desktop_file\n  install_uninstall_script\n}\n\nmain",
    "link": "https://github.com/TheJumpCloud/support/blob/master/PowerShell/JumpCloud%20Commands%20Gallery/Linux%20Commands/Linux%20-%20remote-assist%20-%20Installation%20script.md",
    "description": "This script installs rempte assist application on the Linux machine."
  },
  {
    "name": "Mac - Disable Local User | v1.0 JCCG",
    "type": "mac",
    "command": "#!/bin/bash\n################################################################################\n# This script will disable the *matched* username patterns in the usersToMatch\n# list variable. For Example:\n# Users on the system: administrator, steve, it-staff\n# usersToMatch=(admin it)\n# both the administrator and it-staff would be disabled\n# - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -\n# Test how this command will run by setting the disable variable to false. When\n# set to false the script will identify users to disable and print out a list\n# without disabling the accounts\n################################################################################\n\n# Settings, set true or false\ndisable=true\n\n# Enter user(s) patterns you want to match against (user admin bobsAccount)\nusersToMatch=(admin it)\n\n# Do not modify below this line\n################################################################################\n\n# regexMatchregexPattern\nregexPattern=\"\"\n# build regex matching regexPattern\npos=$(( ${#usersToMatch[*]} - 1 ))\nlast=${usersToMatch[$pos]}\nfor user in ${usersToMatch[@]}; do\n    # add to regexPattern\n    if [[ $user == $last ]]; then\n        regexPattern+=\"${user}[^\\s]*\"\n    else\n        regexPattern+=\"${user}[^\\s]*|\"\n    fi\ndone\n\necho \"Searching System for the following users: ${usersToMatch[@]}\"\necho \"Regex Pattern: $regexPattern\"\n\n# Get usernames on system:\nallUsers=$(dscl . list /Users UniqueID | awk '$2>500{print $1}' | grep -v super.admin | grep -v _jumpcloudserviceaccount)\necho \"-------------------------------------------------------------------------\"\necho \"Accounts on the system:\"\necho \"$allUsers\"\necho \"-------------------------------------------------------------------------\"\n\n# Try to find match:\n# Case insensitive search:\n# set nocasematch option\nshopt -s nocasematch\n\nfoundUsers=()\nfor value in ${allUsers[@]}; do\n    if [[ $value =~ $regexPattern ]]; then\n        echo \"matched $value user\"\n        foundUsers+=($value)\n    fi\ndone\n\n# unset nocasematch option\nshopt -u nocasematch\nloggedInUsers=$(who -u)\necho \"The Following users will be disabled: ${foundUsers[@]}\"\nfor user in ${foundUsers[@]}; do\n    echo \"Disabling $user's login shell...\"\n    if [[ $disable = true ]]; then\n        if echo \"$loggedInUsers\" | grep -iqE \"$user\"; then\n            echo \"logging $user out of system\"\n            sudo launchctl bootout user/$(id -u \"${user}\")\n        fi\n        chsh -s /usr/bin/false $user\n    fi\ndone",
    "link": "https://github.com/TheJumpCloud/support/blob/master/PowerShell/JumpCloud%20Commands%20Gallery/Mac%20Commands/Mac%20-%20Disable%20Local%20User.md",
    "description": "This command will disable the local users that match the regex pattern supplied in the 'usersToMatch' list variable. If for example, a system contains the following users:\n\nSteve, Administrator, IT-Admin\n\nAnd the usersToMatch variable is set to (admin it), both the 'Administrator' and 'IT-Admin' Account would be disabled. The Regex pattern searches usernames for partial matches.\n\nRun this script with disable=false to test what accounts would be disabled before running disable=true. Set the reboot=true variable to reboot the system, upon next restart the disabled users will be unable to login."
  },
  {
    "name": "Mac - Enroll MDM System in DEP | v1.1 JCCG",
    "type": "mac",
    "command": "#!/bin/bash\n\n# Verify JumpCloud MDM\nverify_jc_mdm (){\n    # Check the system for the following profileIdentifier\n    mdmID=\"com.jumpcloud.mdm\"\n    check=$(profiles -Lv | grep \"name: $4\" -4 | awk -F\": \" '/attribute: profileIdentifier/{print $NF}')\n    if [[ $check == *$mdmID* ]] ; then\n        echo \"ProfileIdentifier: ${mdmID} found on system. MDM Verified\"\n        return\n    else\n        echo \"JumpCloud MDM profile not found on system.\"\n        false\n    fi\n}\n\n# If JumpCLoud MDM is on the system check for DEP Enrollment\nif verify_jc_mdm \"$\":; then\n    depApproveCheck=$(profiles status -type enrollment | grep \"Enrolled via DEP:\" | awk 'NF>1{print $NF}')\n    if [[ $depApproveCheck = \"No\" ]]; then\n        echo \"MDM is not DEP enrolled, enrolling and prompted for User Approval\"\n        # Prompt for DEP Enrollment\n        profiles renew -type enrollment\n        exit 0\n    elif [[ $depApproveCheck = \"Yes)\" ]]; then\n        echo \"MDM is DEP enrolled already\"\n        exit 0\n    fi\nelse\n    exit 1\nfi",
    "link": "https://github.com/TheJumpCloud/support/blob/master/PowerShell/JumpCloud%20Commands%20Gallery/Mac%20Commands/Mac%20-%20Enroll%20MDM%20System%20in%20DEP.md",
    "description": "**Note** Before using this command, a [JumpCloud tenant must first be configured with Apple Business Manager](https://jumpcloud.com/blog/integrate-apple-business-manager) or Apple School Manager. Devices must then be added to your MDM server by serial number or Apple Order ID through Apple Business Manager or Apple School Manager. Devices with matching Serial numbers will be displayed in a JumpCloud Tenant under \"DEP Devices\"\n\n![Dep Devices](../Files/depDevices.png)\n\nThis command will enroll a system with the JumpCloud MDM, in DEP. If the system is not enrolled in DEP, the active user of the system will be prompted to approve the MDM profile.\n\n![Dep Prompt](../Files/depPrompt.png)\n\nIf the user clicks the notification window, they'll be brought to the Profiles System Preference panel and prompted to Allow Device Enrollment.\n\n![User Approval](../Files/userApprovalProfile.png)\n\nIf the user clicks allow the device will be DEP enrolled and the MDM profile will become non-removable.\n\n![Enrollment Type](../Files/enrollmentType.png)"
  },
  {
    "name": "Mac - Get logged in user | v1.0 JCCG",
    "type": "mac",
    "command": "stat -f \"%Su\" /dev/console",
    "link": "https://github.com/TheJumpCloud/support/blob/master/PowerShell/JumpCloud%20Commands%20Gallery/Mac%20Commands/Mac%20-%20Get%20Logged%20In%20Users.md",
    "description": "The owner of the /dev/console file will reprepsent the currently logged in user to the OSX GUI. This command ouputs this user.\nIf the command returns **root** then no user has signed in and the machine is online at the login screen."
  },
  {
    "name": "Mac - Install CrowdStrike Falcon Agent | v2.0 JCCG",
    "type": "mac",
    "command": "#!/bin/bash\nCSBaseAddress=\"\"\nCSClientID=\"\"\nCSClientSecret=\"\"\n\n# Installation Token (Only use if you have Require Tokens enabled for your organization)\n# https://falcon.us-2.crowdstrike.com/documentation/page/f8a0f751/host-and-host-group-management#x7be77b4\n\nCSInstallToken=\"\"\n\n############### Do Not Edit Below This Line ###############\n\n# API Base URL and the various endpoints we need\noauthtoken=\"$CSBaseAddress/oauth2/token\"\n\n# Define which version we want to get.\n# 0 means latest. 1 is N-1, 2 is N-2 and so on.\nversion=\"0\"\n\n# Now define the API query we need\nsensorlist=\"$CSBaseAddress/sensors/combined/installers/v1?offset=$version&limit=1&filter=platform%3A%22mac%22\"\nsensordl=\"$CSBaseAddress/sensors/entities/download-installer/v1\"\n\n# Request bearer access token using the API\ntoken=$( /usr/bin/curl -s -X POST \"$oauthtoken\" -H \"accept: application/json\" -H \"Content-Type: application/x-www-form-urlencoded\" -d \"client_id=$CSClientID&client_secret=$CSClientSecret\" )\n\n# Extract the bearer token from the json output above\nBEARER_REGEX_PATTERN='\\\"access_token\\\":\\ \\\"(.+)\\\",'\n\nif [[ $token =~ $BEARER_REGEX_PATTERN ]]; then\n    bearer=\"${BASH_REMATCH[1]}\"\n    echo \"Connected to CrowdStrike\"\nelse\n    echo \"Could not find bearer token\"\n    exit 1\nfi\n\n# Work out the CrowdStrike installer, grab the SHA256 hash and use that to download that installer\nsensorv=$( /usr/bin/curl -s -X GET \"$sensorlist\" -H \"accept: application/json\" -H \"authorization: Bearer $bearer\" )\n\nSHA256_REGEX_PATTERN='\\\"sha256\\\":\\ \"([^\"]*)\"'\n\nif [[ $sensorv =~ $SHA256_REGEX_PATTERN ]]; then\n    sensorsha=\"${BASH_REMATCH[1]}\"\nelse\n    echo \"Could not find sha256 hash\"\n    exit 1\nfi\n\n# Create Temp Folder\nfileName=\"FalconSensor.pkg\"\nDATE=$(date '+%Y-%m-%d-%H-%M-%S')\nTempFolder=\"Download-$DATE\"\nmkdir /tmp/$TempFolder\necho \"Creating /tmp/$TempFolder...\"\n\n# Navigate to Temp Folder\ncd /tmp/$TempFolder\n\n# Download the client.\necho \"Beginning CrowdStrike Sensor Download...\"\ndownload=$( /usr/bin/curl -H \"Accept: application/octet-stream\" -H \"Authorization: bearer $bearer\" -o \"$fileName\" \"$sensordl?id=$sensorsha\")\nres=$?\n\nif [[ \"$res\" != \"0\" ]]; then\n    echo \"Download failed with: $res\"\n    echo \"Cleaning up files...\"\n    rm -r /tmp/$TempFolder\n    echo \"Deleted /tmp/$TempFolder\"\n    exit 1\nfi\n\ninstaller -verboseR -package \"/tmp/$TempFolder/$fileName\" -target /\n\n# Validate the install and license status\nif [[ \"$CSInstallToken\" != \"\" ]]; then\n    sudo /Applications/Falcon.app/Contents/Resources/falconctl provisioning-token $CSInstallToken\nfi\n\nstats=$(/Applications/Falcon.app/Contents/Resources/falconctl stats > /dev/null 2>&1)\nstatsStatus=$?\nif [[ $statsStatus == 0 ]]; then\n    echo \"License was applied successfully\"\nelse\n    echo \"License was not applied, please verify that the CrowdStrike Falcon MDM Settings profile is applied to this device\"\n    exit 1\nfi\n\n# Remove Temp Folder and download\nrm -r /tmp/$TempFolder\necho \"Deleted /tmp/$TempFolder\"",
    "link": "https://github.com/TheJumpCloud/support/blob/master/PowerShell/JumpCloud%20Commands%20Gallery/Mac%20Commands/Mac%20-%20Install%20CrowdStrike%20Falcon%20Agent.md",
    "description": "This command will download and install the CrowdStrike Falcon Agent to the device if it isn't already installed. The command will leverage CrowdStrike's API to find and download the latest version of the Falcon Agent onto the local machine.\n\nIn order to use this command, follow the instructions from the [Installing the CrowdStrike Falcon Agent KB](https://support.jumpcloud.com/s/article/Installing-the-Crowdstrike-Falcon-Agent)\n\n[Richard Purves' blog post on Downloading Crowdstrike](https://richard-purves.com/2022/05/03/downloading-crowdstrike-via-api-for-fun-and-profit/) inspired this command template.\n\nSpecifically for this command:\n\n1. Create a CrowdStrike API Client with the \"SENSOR DOWNLOAD\" Read scope and make note of the ClientID and ClientSecret. Refer to CrowdStrike's article [Getting Access to the CrowdStrike API](https://www.crowdstrike.com/blog/tech-center/get-access-falcon-apis/) for further information\n2. Set the 3 variables (CSBaseAddress, CSClientID, CSClientSecret) to their respective values for your CrowdStrike API Client\n3. Extend the command timeout to a value that makes sense in your environment. The suggested command timeout for an environment with average network speeds on devices with average computing power is 10 minutes. Note that the command may timeout with a 124 error code in the command result window if not extended, but the script will continue to run."
  },
  {
    "name": "Mac - Install JumpCloud Password Manager App | v1.2 JCCG",
    "type": "mac",
    "command": "#!/bin/bash\n\n# This script will install password manager in Users/$user/Applications for all user accounts\n\nDownloadUrl=\"https://cdn.pwm.jumpcloud.com/DA/release/JumpCloud-Password-Manager-latest.dmg\"\n\nregex='^https.*.dmg$'\nif [[ $DownloadUrl =~ $regex ]]; then\n    echo \"URL points to direct DMG download\"\n    validLink=\"True\"\nelse\n    echo \"Searching headers for download links\"\n    urlHead=$(curl -s --head $DownloadUrl)\n\n    locationSearch=$(echo \"$urlHead\" | grep https:)\n\n    if [ -n \"$locationSearch\" ]; then\n\n        locationRaw=$(echo \"$locationSearch\" | cut -d' ' -f2)\n\n        locationFormatted=\"$(echo \"${locationRaw}\" | tr -d '[:space:]')\"\n\n        regex='^https.*'\n        if [[ $locationFormatted =~ $regex ]]; then\n            echo \"Download link found\"\n            DownloadUrl=$(echo \"$locationFormatted\")\n        else\n            echo \"No https location download link found in headers\"\n            exit 1\n        fi\n\n    else\n\n        echo \"No location download link found in headers\"\n        exit 1\n    fi\n\nfi\n\n\n\n#Create Temp Folder\nDATE=$(date '+%Y-%m-%d-%H-%M-%S')\n\nTempFolder=\"Download-$DATE\"\n\nmkdir /tmp/$TempFolder\n\n# Navigate to Temp Folder\ncd /tmp/$TempFolder\n\n# Download File into Temp Folder\ncurl -s -O \"$DownloadUrl\"\n\n# Capture name of Download File\nDownloadFile=\"$(ls)\"\n\necho \"Downloaded $DownloadFile to /tmp/$TempFolder\"\n\n# Verifies DMG File\nregex='\\.dmg$'\nif [[ $DownloadFile =~ $regex ]]; then\n    DMGFile=\"$(echo \"$DownloadFile\")\"\n    echo \"DMG File Found: $DMGFile\"\nelse\n    echo \"File: $DownloadFile is not a DMG\"\n    rm -r /tmp/$TempFolder\n    echo \"Deleted /tmp/$TempFolder\"\n    exit 1\nfi\n\n# Mount DMG File -nobrowse prevents the volume from popping up in Finder\n\nhdiutilAttach=$(hdiutil attach /tmp/$TempFolder/$DMGFile -nobrowse)\n\necho \"Used hdiutil to mount $DMGFile \"\n\nerr=$?\nif [ ${err} -ne 0 ]; then\n    echo \"Could not mount $DMGFile Error: ${err}\"\n    rm -r /tmp/$TempFolder\n    echo \"Deleted /tmp/$TempFolder\"\n    exit 1\nfi\n\nregex='\\/Volumes\\/.*'\nif [[ $hdiutilAttach =~ $regex ]]; then\n    DMGVolume=\"${BASH_REMATCH[@]}\"\n    echo \"Located DMG Volume: $DMGVolume\"\nelse\n    echo \"DMG Volume not found\"\n    rm -r /tmp/$TempFolder\n    echo \"Deleted /tmp/$TempFolder\"\n    exit 1\nfi\n\n# Identify the mount point for the DMG file\nDMGMountPoint=\"$(hdiutil info | grep \"$DMGVolume\" | awk '{ print $1 }')\"\n\necho \"Located DMG Mount Point: $DMGMountPoint\"\n\n# Capture name of App file\n\ncd \"$DMGVolume\"\n\nAppName=\"$(ls | Grep .app)\"\n\ncd ~\n\necho \"Located App: $AppName\"\n\n\nDMGAppPath=$(find \"$DMGVolume\" -name \"*.app\" -depth 1)\n\nuserInstall=false\n\nfor user in $(dscl . list /Users | grep -vE 'root|daemon|nobody|^_')\ndo\n    if [[ -d /Users/$user ]]; then\n        # Create ~/Applications folder\n        if [[ ! -d /Users/$user/Applications ]]; then\n            mkdir /Users/$user/Applications\n        fi\n        if [[ -d /Users/$user/Applications/JumpCloud\\ Password\\ Manager.app ]]; then\n            # remove if exists\n            rm -rf /Users/$user/Applications/JumpCloud\\ Password\\ Manager.app\n        fi\n\n        # Copy the contents of the DMG file to /Users/$user/Applications/\n        # Preserves all file attributes and ACLs\n        cp -pPR \"$DMGAppPath\" /Users/$user/Applications/\n\n        err=$?\n        if [ ${err} -ne 0 ]; then\n            echo \"Could not copy $DMGAppPath Error: ${err}\"\n            hdiutil detach $DMGMountPoint\n            echo \"Used hdiutil to detach $DMGFile from $DMGMountPoint\"\n            rm -r /tmp/$TempFolder\n            echo \"Deleted /tmp/$TempFolder\"\n            exit 1\n        fi\n\n        userInstall=true\n        echo \"Copied $DMGAppPath to /Users/$user/Applications\"\n\n        # Create an alias on desktop\n        ln -s /Users/$user/Applications/JumpCloud\\ Password\\ Manager.app /Users/$user/Desktop/JumpCloud\\ Password\\ Manager.app\n    fi\ndone\n\n\n# Check if password manager is installed in /Applications; remove if we installed in user directory\nif [ -d /Applications/JumpCloud\\ Password\\ Manager.app ] && [ $userInstall = true ]; then\n    # remove if exists\n    rm -rf /Applications/JumpCloud\\ Password\\ Manager.app\nfi\n\n# Unmount the DMG file\nhdiutil detach $DMGMountPoint\n\necho \"Used hdiutil to detach $DMGFile from $DMGMountPoint\"\n\nerr=$?\nif [ ${err} -ne 0 ]; then\n    abort \"Could not detach DMG: $DMGMountPoint Error: ${err}\"\nfi\n\n# Remove Temp Folder and download\nrm -r /tmp/$TempFolder\n\necho \"Deleted /tmp/$TempFolder\"\n\nexit",
    "link": "https://github.com/TheJumpCloud/support/blob/master/PowerShell/JumpCloud%20Commands%20Gallery/Mac%20Commands/Mac%20-%20Install%20JumpCloud%20Password%20Manager%20App.md",
    "description": "This command will download and install the JumpCloud Password Manager to the device if it isn't already installed. On slower networks, timeouts with exit code 127 can occur. Manually setting the default timeout limit to 600 seconds may be advisable."
  },
  {
    "name": "Mac - Install Sentinel One Agent | v1.0 JCCG",
    "type": "mac",
    "command": "#!/bin/bash\n\nsentinelToken=\"YOURTOKEN\"\nDownloadURL=\"https://path/to/url.pkg\"\n\n############### Do Not Edit Below This Line ###############\n\nfilename=\"sentineloneagent.pkg\"\n\n# Check if already installed\nif [[ -d /Applications/SentinelOne/ ]]\n  then\n    echo \"Sentinel One Agent is Already Installed. Exiting...\"\n    exit 0\nfi\n\n# Create Temp Folder\n#\nDATE=$(date '+%Y-%m-%d-%H-%M-%S')\nTempFolder=\"Download-$DATE\"\nmkdir /tmp/$TempFolder\n\n# Navigate to Temp Folder\n#\ncd /tmp/$TempFolder\n\n# Download Sentinel One file\ncurl -o $filename $DownloadURL\n\n\nDownloadFile=\"$(ls)\"\necho \"Downloaded $DownloadFile to /tmp/$TempFolder\"\n\n# Verifies PKG File\n#\nregex='\\.pkg$'\nif [[ $DownloadFile =~ $regex ]]; then\n    PKGFile=\"$(echo \"$DownloadFile\")\"\n    echo \"PKG File Found: $PKGFile\"\nelse\n    echo \"File: $DownloadFile is not a PKG\"\n    rm -r /tmp/$TempFolder\n    echo \"Deleted /tmp/$TempFolder\"\n    exit 1\nfi\n\n#Set Token\necho $sentinelToken > /tmp/$TempFolder/com.sentinelone.registration-token\n\n# Check signature and install\ncheck_pkg_sign=$(pkgutil --check-signature $PKGFile)\nif [[ $check_pkg_sign == *\"AYE5J54KN\"* ]] && [[ $check_pkg_sign == *\"Status: signed by a developer certificate issued by Apple\"* ]] && [[ $check_pkg_sign == *\"Notarization: trusted by the Apple notary service\"* ]]\nthen\n    echo \"Package is signed. Installing...\"\n\n    # Install Agent\n    /usr/sbin/installer -pkg /tmp/$TempFolder/$PKGFile -target /Applications\nelse\n    echo \"Package is unsigned. Exiting...\"\n    exit 1\nfi\n\n# Remove Temp Folder and download\nrm -r /tmp/$TempFolder\necho \"Deleted /tmp/$TempFolder\"",
    "link": "https://github.com/TheJumpCloud/support/blob/master/PowerShell/JumpCloud%20Commands%20Gallery/Mac%20Commands/Mac%20-%20Install%20Sentinel%20One%20Agent.md",
    "description": "This command will download and install the Sentinel One Agent to the device if it isn't already installed.\n\nSpecifically for this command:\n\n1. Download the Sentinel One Agent installer and host it at a URL that your devices can access. Set this URL to the \"DownloadURL\" of this script.\n2. Extend the command timeout to a value that makes sense in your environment. The suggested command timeout for an environment with average network speeds on devices with average computing power is 10 minutes. Note that the command may timeout with a 124 error code in the command result window if not extended, but the script will continue to run."
  },
  {
    "name": "Mac - List All Users | v1.0 JCCG",
    "type": "mac",
    "command": "dscl . list /Users | grep -v '^_' | grep -v 'daemon' | grep -v 'nobody' | grep -v 'root'",
    "link": "https://github.com/TheJumpCloud/support/blob/master/PowerShell/JumpCloud%20Commands%20Gallery/Mac%20Commands/Mac%20-%20List%20All%20Users.md",
    "description": "Lists all users on a Mac"
  },
  {
    "name": "Mac - List Available Updates | v1.0 JCCG",
    "type": "mac",
    "command": "softwareupdate -l",
    "link": "https://github.com/TheJumpCloud/support/blob/master/PowerShell/JumpCloud%20Commands%20Gallery/Mac%20Commands/Mac%20-%20List%20Available%20Updates.md",
    "description": "Shows available updates on a Mac system"
  },
  {
    "name": "Mac - Pull jcagent.log | v1.1 JCCG",
    "type": "mac",
    "command": "#!/bin/bash\nagentLogFile=\"/var/log/jcagent.log\"\necho \"============================= Begin Log ===============================\"\n# Pull log data and echo to standard out\nwhile IFS=\"\" read -r line; do\n    echo \"$line\"\ndone < $agentLogFile\necho \"============================== End Log ================================\"",
    "link": "https://github.com/TheJumpCloud/support/blob/master/PowerShell/JumpCloud%20Commands%20Gallery/Mac%20Commands/Mac%20-%20Pull%20jcagent.log.md",
    "description": "Pulls the JC agent log from a Mac system and prints each line to the JumpCloud command result log. This log can be saved as a .log file."
  },
  {
    "name": "Mac - Refresh Login Window  |  v1.0 JCCG",
    "type": "mac",
    "command": "loginWindowProccess=\"$(ps -Ajc | grep loginwindow | awk '{print $2}')\"\nkill -9 $loginWindowProccess",
    "link": "https://github.com/TheJumpCloud/support/blob/master/PowerShell/JumpCloud%20Commands%20Gallery/Mac%20Commands/Mac%20-%20Refresh%20Login%20Window.md",
    "description": "Refreshes the Mac login window by restarting the login window process. This can be used to reveal a user who was locked out on a Mac machine but has been unlocked without restarting the machine.\n\n**Warning** if run when a user is signed in this command will sign them out and bring them to the login screen."
  },
  {
    "name": "Mac - Rename System HostName, LocalHostName and ComputerName from JumpCloud | v2.0 JCCG",
    "type": "mac",
    "command": "#!/bin/bash\n################################################################################\n# This script will update the system hostname, localHostname & computerName to\n# match the value of this systems displayName in the JumpCloud console.\n# An API Key with read access is required to run this script.\n################################################################################\n\n# Set Read API KEY - Required to read \"DisplayName\" from console.jumpcloud.com\nAPI_KEY=\"YourReadOnlyAPIKey\"\n\n# ------- Do not modify below this line ------\n# Functions\nfunction validateVariable() {\n    var=$1\n    if [[ -z \"$var\" ]]; then\n        echo \"[error] Required variable was null, exiting...\"\n        exit 1\n    fi\n} >&2\nfunction validateLocalHostname() {\n    var=$1\n    # Validate LocalHostName is Alphanumeric, contains '-' and no spaces\n    # Attempt to remove the space characters if they exist\n    if [[ \"$var\" =~ \\ |\\' ]]; then\n        echo \"[debug] whitespace characters found in LocalHostName, removing...\"\n        var=\"${var//[[:blank:]]/}\"\n    fi\n    # Check for special characters & length of 63 characters\n    # does not begin or end with '-'\n    if [[ \"$var\" =~ ^[^-][a-zA-Z0-9-]{1,63}[^-]$ ]]; then\n        echo \"[debug] LocalHostname appears to be valid: $var\"\n    else\n        echo \"[debug] special characters found in LocalHostname, removing...\"\n        # Attempt to remove special characters if they exist\n        var=$(echo \"$var\" | sed \"s/[^[:alnum:]-]//g\")\n        # Finally validate updated variable\n        if [[ \"$var\" =~ ^[^-][a-zA-Z0-9-]{1,63}[^-]$ ]]; then\n            echo \"[debug] LocalHostname appears to be valid: $var\"\n        else\n            echo \"[error] LocalHostName could not be set, exiting\"\n            exit 1\n        fi\n    fi\n    validatedHostname=\"$var\"\n}\n# Get System Key\nfunction getSystemKey() {\n    conf=\"$(cat /opt/jc/jcagent.conf)\"\n    regex='\\\"systemKey\\\":\\\"[a-zA-Z0-9]{24}\\\"'\n    if [[ $conf =~ $regex ]]; then\n        systemKey=\"${BASH_REMATCH[@]}\"\n    fi\n    # echo \"$(date \"+%Y-%m-%dT%H:%M:%S\"): systemKey = $systemKey \"\n    regex='[a-zA-Z0-9]{24}'\n    if [[ $systemKey =~ $regex ]]; then\n        systemID=\"${BASH_REMATCH[@]}\"\n    fi\n    # echo \"$(date \"+%Y-%m-%dT%H:%M:%S\"): systemID = $systemID \"\n    echo \"$systemID\"\n}\nsystemID=$(getSystemKey)\nsearch=$(\n    curl -s -f -X GET https://console.jumpcloud.com/api/systems/${systemID} \\\n        -H 'Accept: application/json' \\\n        -H 'Content-Type: application/json' \\\n        -H \"x-api-key: ${API_KEY}\"\n)\n# regex pattern to search displayNames. This pattern selects the text after \"displayName\":\" and before \",\nregex='(\"displayName\":\")([^\"]*)(\",)'\nif [[ $search =~ $regex ]]; then\n    match=\"${BASH_REMATCH[2]}\"\nfi\n\n# Get old system name\noldName=$(scutil --get HostName)\n# If hostname is not set for any reason, try again with localHostName\nif [[ \"$oldName\" == \"\" ]];then\n    echo \"[debug] HostName was not set, trying to get the LocalHostName\"\n    oldName=$(scutil --get LocalHostName)\nfi\n# Validate oldName, Match (new Name), systemID\nvalidateVariable \"$oldName\"\nvalidateVariable \"$systemID\"\nvalidateVariable \"$match\"\necho \"[status] Attempting to set ComputerName, LocalHostName & Hostname to: $match\"\n# Validate localHostName is alphanumeric, 63 chars in length & no special chars\nvalidateLocalHostname \"$match\"\n# if validatedHostname variable exists, continue\nvalidateVariable \"$validatedHostname\"\necho \"[debug] script variables were validated\"\n# set the hostname, LocalHostName and computer name\n# hostname:\nscutil --set HostName \"$match\"\nif [[ $? -eq 0 ]]; then\n    echo \"[status] HostName Set: $(scutil --get HostName)\"\nelse\n    echo \"[error] Hostname was not set\"\n    exit 1\nfi\n\n\nif validateVariable \"$validatedHostname\"; then\n    # Set validated variable\n    scutil --set LocalHostName \"$validatedHostname\"\n    if [[ $? -eq 0 ]]; then\n        echo \"[status] LocalHostName Set: $(scutil --get LocalHostName)\"\n    else\n        echo \"[error] LocalHostName was not set\"\n        exit 1\n    fi\nelse\n    echo \"[error] Could not validate LocalHostName\"\n    exit 1\nfi\nscutil --set ComputerName \"$match\"\nif [[ $? -eq 0 ]]; then\n    echo \"[status] ComputerName Set: $(scutil --get ComputerName)\"\nelse\n    echo \"[error] ComputerName was not set\"\n    exit 1\nfi\n\necho \"[status] $oldName was renamed to $match\"\nexit 0",
    "link": "https://github.com/TheJumpCloud/support/blob/master/PowerShell/JumpCloud%20Commands%20Gallery/Mac%20Commands/Mac%20-%20Rename%20System%20HostName%20LocalHostName%20and%20ComputerName%20from%20JumpCloud.md",
    "description": "This script uses a read only API key to gather info about the current system. Using Regex, the code filters out the displayName of a given system and sets the system HostName, LocalHostName and ComputerName to the name set in the JumpCloud console.\n\nPlease note, there are specific rules for the LocalHostName value. LocalHostNames must:\n\n* Be a maximum 63 characters in length\n* Contain no whitespace characters\n* Contain only alphanumeric characters and hyphens '-'\n* Hyphens must not exist at the beginning or end of the string ex. '-system-1-' is not allowed\n\nThis script will attempt to strip whitespace and special characters before setting the system's LocalHostName. HostNames and ComputerNames are not modified as their requirements differ from the LocalHostName."
  },
  {
    "name": "Mac - Run Once Template - Remove System From Associated System Group | v1.0 JCCG",
    "type": "mac",
    "command": "# Populate systemGroupID variable before running the command\n\nsystemGroupID=''\n\n#--------------------Enter command below this line--------------------\n\n\n#--------------------Do not modify below this line--------------------\n\n# Parse the systemKey from the conf file.\nconf=\"$(cat /opt/jc/jcagent.conf)\"\nregex='\\\"systemKey\\\":\\\"[a-zA-Z0-9]{24}\\\"'\n\nif [[ $conf =~ $regex ]]; then\n\tsystemKey=\"${BASH_REMATCH[@]}\"\nfi\n\nregex='[a-zA-Z0-9]{24}'\nif [[ $systemKey =~ $regex ]]; then\n\tsystemID=\"${BASH_REMATCH[@]}\"\nfi\n\n# Get the current time.\nnow=$(date -u \"+%a, %d %h %Y %H:%M:%S GMT\")\n\n# create the string to sign from the request-line and the date\nsignstr=\"POST /api/v2/systemgroups/${systemGroupID}/members HTTP/1.1\\ndate: ${now}\"\n\n# create the signature\nsignature=$(printf \"$signstr\" | openssl dgst -sha256 -sign /opt/jc/client.key | openssl enc -e -a | tr -d '\\n')\n\ncurl -s \\\n\t-X 'POST' \\\n\t-H 'Content-Type: application/json' \\\n\t-H 'Accept: application/json' \\\n\t-H \"Date: ${now}\" \\\n\t-H \"Authorization: Signature keyId=\\\"system/${systemID}\\\",headers=\\\"request-line date\\\",algorithm=\\\"rsa-sha256\\\",signature=\\\"${signature}\\\"\" \\\n\t-d '{\"op\": \"remove\",\"type\": \"system\",\"id\": \"'${systemID}'\"}' \\\n\t\"https://console.jumpcloud.com/api/v2/systemgroups/${systemGroupID}/members\"\n\necho \"JumpCloud system: ${systemID} removed from system group: ${systemGroupID}\"",
    "link": "https://github.com/TheJumpCloud/support/blob/master/PowerShell/JumpCloud%20Commands%20Gallery/Mac%20Commands/Mac%20-%20Run%20Once%20Template%20-%20Remove%20System%20From%20Associated%20System%20Group.md",
    "description": "This template can be modified to satisfy use cases where admins wish to run a command once on a number of target systems and have the system automatically removed from the system group which associates the system with the command.\n\n*Directly associating JumpCloud systems to JumpCloud commands? [No problem refer to this template for removing systems from a JumpCloud command](https://github.com/TheJumpCloud/support/blob/master/PowerShell/JumpCloud%20Commands%20Gallery/Mac%20Commands/Mac%20-%20Run%20Once%20Template%20-%20Remove%20System%20From%20Command.md)*\n\nBefore running this command the variable **systemGroupID=''** must be populated.\n\nTo find the systemGroupID for a JumpCloud system group navigate to the \"GROUPS\" section of the JumpCloud admin portal and select the system group to bring up the system group details. Within the URL of the selected command the systemGroupID will be the 24 character string between 'system/' and '/details'. The JumpCloud PowerShell command [Get-JCGroup](https://github.com/TheJumpCloud/support/wiki/Get-JCGroup) can also be used to find the systemGroupID. The systemGroupID is the 'id' value which will be displayed for each JumpCloud group when Get-JCGroup is called.\n\n![systemGroupID example](https://github.com/TheJumpCloud/support/blob/master/PowerShell/JumpCloud%20Commands%20Gallery/Files/systemGroupID.png?raw=true)\n\nEnter the payload of the command under the line '#--------------------Enter command below this line--------------------'\n\nAfter the command is run the system is removed from the system group specified via the JumpCloud system context API. [Learn more about the JumpCloud system context API here](https://docs.jumpcloud.com/2.0/authentication-and-authorization/system-context)."
  },
  {
    "name": "Mac - Run Once Template - Remove System From Command | v1.0 JCCG",
    "type": "mac",
    "command": "# Populate commandID variable before running the command\n\ncommandID=''\n\n#--------------------Enter command below this line--------------------\n\n\n#--------------------Do not modify below this line--------------------\n\n# Parse the systemKey from the conf file.\nconf=\"$(cat /opt/jc/jcagent.conf)\"\nregex='\\\"systemKey\\\":\\\"[a-zA-Z0-9]{24}\\\"'\n\nif [[ $conf =~ $regex ]]; then\n\tsystemKey=\"${BASH_REMATCH[@]}\"\nfi\n\nregex='[a-zA-Z0-9]{24}'\nif [[ $systemKey =~ $regex ]]; then\n\tsystemID=\"${BASH_REMATCH[@]}\"\nfi\n\n# Get the current time.\nnow=$(date -u \"+%a, %d %h %Y %H:%M:%S GMT\")\n\n# create the string to sign from the request-line and the date\nsignstr=\"POST /api/v2/systems/${systemID}/associations?targets=command HTTP/1.1\\ndate: ${now}\"\n\n# create the signature\nsignature=$(printf \"$signstr\" | openssl dgst -sha256 -sign /opt/jc/client.key | openssl enc -e -a | tr -d '\\n')\n\ncurl -s \\\n\t-X 'POST' \\\n\t-H 'Content-Type: application/json' \\\n\t-H 'Accept: application/json' \\\n\t-H \"Date: ${now}\" \\\n\t-H \"Authorization: Signature keyId=\\\"system/${systemID}\\\",headers=\\\"request-line date\\\",algorithm=\\\"rsa-sha256\\\",signature=\\\"${signature}\\\"\" \\\n\t-d '{\"op\": \"remove\",\"type\": \"command\",\"id\": \"'${commandID}'\"}' \\\n\t\"https://console.jumpcloud.com/api/v2/systems/${systemID}/associations?targets=command\"\n\necho \"JumpCloud system: ${systemID} removed from command target list\"",
    "link": "https://github.com/TheJumpCloud/support/blob/master/PowerShell/JumpCloud%20Commands%20Gallery/Mac%20Commands/Mac%20-%20Run%20Once%20Template%20-%20Remove%20System%20From%20Command.md",
    "description": "This template can be used to satisfy use cases where admins wish to run a command once on a number of target systems and have the system automatically removed from the commands system target list after the command is run.\n\n*Using a system group for associating systems with JumpCloud commands? [No problem refer to this template for removing systems from a JumpCloud command from an associated JumpCloud system group](https://github.com/TheJumpCloud/support/blob/master/PowerShell/JumpCloud%20Commands%20Gallery/Mac%20Commands/Mac%20-%20Run%20Once%20Template%20-%20Remove%20System%20From%20Associated%20System%20Group.md).*\n\nBefore running this command the variable **commandID=''** must be populated.\n\n![commanID example](https://github.com/TheJumpCloud/support/blob/master/PowerShell/JumpCloud%20Commands%20Gallery/Files/commandID.png?raw=true)\n\nTo find the commandID within the JumpCloud admin console select the command to expand the command details. Within the URL of the selected command the commandID will be the 24 character string between 'commands/' and '/details'. The JumpCloud PowerShell command [Get-JCCommand](https://github.com/TheJumpCloud/support/wiki/Get-JCCommand) can also be used to find the commandID which will reveal the commandID in the '_id' field.\n\nEnter the payload of the command under the line '#--------------------Enter command below this line--------------------'\n\nAfter the command is run the system is removed from the command via the JumpCloud system context API. [Learn more about the JumpCloud system context API here](https://docs.jumpcloud.com/2.0/authentication-and-authorization/system-context)."
  },
  {
    "name": "Mac - Set Agent Log Level to Debug | v1.0 JCCG",
    "type": "mac",
    "command": "#!/bin/bash\n\n# File Locations\nlaunchDaemon=\"/Library/LaunchDaemons/com.jumpcloud.agentlogdebug.plist\"\nscriptFile=\"/var/tmp/jc_setAgent.sh\"\n\n# Write the daemon\ncat <<EOF > $launchDaemon\n<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n<!DOCTYPE plist PUBLIC \"-//Apple//DTD PLIST 1.0//EN\" \"http://www.apple.com/DTDs/PropertyList-1.0.dtd\">\n<plist version=\"1.0\">\n<dict>\n\t<key>Label</key>\n\t<string>com.jumpcloud.agentlogdebug</string>\n\t<key>ProgramArguments</key>\n\t<array>\n\t\t<string>/bin/bash</string>\n\t\t<string>/var/tmp/jc_setAgent.sh</string>\n\t</array>\n    <key>RunAtLoad</key>\n\t<true/>\n</dict>\n</plist>\nEOF\n\n# Create the script file:\ncat <<'EOF' > $scriptFile\n#!/bin/bash\n\n# Set Debug Level | Either \"DEBUG\" or \"TRACE\"\nsetLevel=\"DEBUG\"\n\n# Sleep 10s to let wrapper command exit 0\nsleep 10\n\n# File Locations\nlogLevelFile=\"/opt/jc/loglevel.cache\"\nlaunchDaemon=\"/Library/LaunchDaemons/com.jumpcloud.agentlogdebug.plist\"\nscriptFile=\"/var/tmp/jc_setAgent.sh\"\n\nlogLevel () {\n    # Valid Log Levels\n    list=(\"DEBUG\" \"TRACE\")\n    if [[ ${list[*]} =~ $1 ]]; then\n        echo \"$(date \"+%Y-%m-%d %H:%M:%S\"): Setting JumpCloud-Agent debug Level to $1\"\nprintf $1 > $logLevelFile\n\n    echo \"$(date \"+%Y-%m-%d %H:%M:%S\"): Log Level Set to: $(cat $logLevelFile)\"\n    else\n        echo \"$(date \"+%Y-%m-%d %H:%M:%S\"): Error setting log level, run script with elevated permissions\"\n        exit 1\n    fi\n}\n\n# Call LogLevel Function to set log level\nlogLevel $setLevel\n\n# Restart Agent to start logging with new level\nlaunchctl stop com.jumpcloud.darwin-agent\n\n# Clean up after restarting agent\n# Remove launchDaemon\nrm $launchDaemon\n# Remove this script\nrm -- \"$0\"\nEOF\n\n# Load the Daemon\nlaunchctl load -w $launchDaemon\n\nexit 0",
    "link": "https://github.com/TheJumpCloud/support/blob/master/PowerShell/JumpCloud%20Commands%20Gallery/Mac%20Commands/Mac%20-%20Set%20Agent%20Log%20Level%20to%20Debug.md",
    "description": "This command will set the JumpCloud Agent Log Level to Debug. The log level can be set to trace by setting the `setLevel=\"DEBUG\"` variable to `setLevel=\"TRACE\"` After the command is run, a launchDaemon is triggered which loads a second script to set the log Level. That second script restarts the JumpCloud Agent and removes the launchDaemon and deletes itself. The launchDameon: com.jumpcloud.agentlogdefault.plist will be unloaded on system restart."
  },
  {
    "name": "Mac - Set Agent Log Level to Default | v1.0 JCCG",
    "type": "mac",
    "command": "#!/bin/bash\n\n# File Locations\nlaunchDaemon=\"/Library/LaunchDaemons/com.jumpcloud.agentlogdefault.plist\"\nscriptFile=\"/var/tmp/jc_setAgent.sh\"\n\n# Write the daemon\ncat <<EOF > $launchDaemon\n<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n<!DOCTYPE plist PUBLIC \"-//Apple//DTD PLIST 1.0//EN\" \"http://www.apple.com/DTDs/PropertyList-1.0.dtd\">\n<plist version=\"1.0\">\n<dict>\n\t<key>Label</key>\n\t<string>com.jumpcloud.agentlogdefault</string>\n\t<key>ProgramArguments</key>\n\t<array>\n\t\t<string>/bin/bash</string>\n\t\t<string>/var/tmp/jc_setAgent.sh</string>\n\t</array>\n    <key>RunAtLoad</key>\n\t<true/>\n</dict>\n</plist>\nEOF\n\n# Create the script file:\ncat <<'EOF' > $scriptFile\n#!/bin/bash\n\n# Sleep 10s to let wrapper command exit 0\nsleep 10\n\n# File Locations\nlogLevelFile=\"/opt/jc/loglevel.cache\"\nlaunchDaemon=\"/Library/LaunchDaemons/com.jumpcloud.agentlogdefault.plist\"\nscriptFile=\"/var/tmp/jc_setAgent.sh\"\n\n# Read $logLevelFile, if exists, delete\nif [[ -f $logLevelFile ]]; then\n    rm $logLevelFile\nfi\n\n# Restart Agent to start logging with new level\nlaunchctl stop com.jumpcloud.darwin-agent\n\n# Clean up after restarting agent\n# Remove launchDaemon\nrm $launchDaemon\n# Remove this script\nrm -- \"$0\"\nEOF\n\n# Load the Daemon\nlaunchctl load -w $launchDaemon\n\nexit 0",
    "link": "https://github.com/TheJumpCloud/support/blob/master/PowerShell/JumpCloud%20Commands%20Gallery/Mac%20Commands/Mac%20-%20Set%20Agent%20Log%20Level%20to%20Default.md",
    "description": "This command will set the JumpCloud Agent Log Level back to the default setting. After the command is run, a launchDaemon is triggered which loads a second script to set the Log Level. That second script restarts the JumpCloud Agent and removes the launchDaemon and deletes itself. The launchDameon: com.jumpcloud.agentlogdefault.plist will be unloaded on system restart."
  },
  {
    "name": "Mac - Set Agent Log Level to Trace | v1.0 JCCG",
    "type": "mac",
    "command": "#!/bin/bash\n\n# File Locations\nlaunchDaemon=\"/Library/LaunchDaemons/com.jumpcloud.agentlogtrace.plist\"\nscriptFile=\"/var/tmp/jc_setAgent.sh\"\n\n# Write the daemon\ncat <<EOF > $launchDaemon\n<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n<!DOCTYPE plist PUBLIC \"-//Apple//DTD PLIST 1.0//EN\" \"http://www.apple.com/DTDs/PropertyList-1.0.dtd\">\n<plist version=\"1.0\">\n<dict>\n\t<key>Label</key>\n\t<string>com.jumpcloud.agentlogtrace</string>\n\t<key>ProgramArguments</key>\n\t<array>\n\t\t<string>/bin/bash</string>\n\t\t<string>/var/tmp/jc_setAgent.sh</string>\n\t</array>\n    <key>RunAtLoad</key>\n\t<true/>\n</dict>\n</plist>\nEOF\n\n# Create the script file:\ncat <<'EOF' > $scriptFile\n#!/bin/bash\n\n# Set Debug Level | Either \"DEBUG\" or \"TRACE\"\nsetLevel=\"TRACE\"\n\n# Sleep 10s to let wrapper command exit 0\nsleep 10\n\n# File Locations\nlogLevelFile=\"/opt/jc/loglevel.cache\"\nlaunchDaemon=\"/Library/LaunchDaemons/com.jumpcloud.agentlogtrace.plist\"\nscriptFile=\"/var/tmp/jc_setAgent.sh\"\n\nlogLevel () {\n    # Valid Log Levels\n    list=(\"DEBUG\" \"TRACE\")\n    if [[ ${list[*]} =~ $1 ]]; then\n        echo \"$(date \"+%Y-%m-%d %H:%M:%S\"): Setting JumpCloud-Agent debug Level to $1\"\nprintf $1 > $logLevelFile\n\n    echo \"$(date \"+%Y-%m-%d %H:%M:%S\"): Log Level Set to: $(cat $logLevelFile)\"\n    else\n        echo \"$(date \"+%Y-%m-%d %H:%M:%S\"): Error setting log level, run script with elevated permissions\"\n        exit 1\n    fi\n}\n\n# Call LogLevel Function to set log level\nlogLevel $setLevel\n\n# Restart Agent to start logging with new level\nlaunchctl stop com.jumpcloud.darwin-agent\n\n# Clean up after restarting agent\n# Remove launchDaemon\nrm $launchDaemon\n# Remove this script\nrm -- \"$0\"\nEOF\n\n# Load the Daemon\nlaunchctl load -w $launchDaemon\n\nexit 0",
    "link": "https://github.com/TheJumpCloud/support/blob/master/PowerShell/JumpCloud%20Commands%20Gallery/Mac%20Commands/Mac%20-%20Set%20Agent%20Log%20Level%20to%20Trace.md",
    "description": "This command will set the JumpCloud Agent Log Level to Trace. The log level can be set to trace by setting the `setLevel=\"DEBUG\"` variable to `setLevel=\"TRACE\"` After the command is run, a launchDaemon is triggered which loads a second script to set the log Level. That second script restarts the JumpCloud Agent and removes the launchDaemon and deletes itself. The launchDameon: com.jumpcloud.agentlogdefault.plist will be unloaded on system restart."
  },
  {
    "name": "Mac - Set Auto Logout Delay | v1.0 JCCG",
    "type": "mac",
    "command": "# Update the AutoLogOutDelay Variable\n# This variable is defined in seconds by displayed as a minutes in System Preferences\n# The minimum number of minutes this payload can take is 5 minutes (300 seconds)\n# The maximum value this payload can take is 60 minutes (3600 seconds)\n# To disable this setting set the value to 0\n\nAutoLogOutDelay='300'\n\n#------- Do not modify below this line ------\n\nif [ \"$AutoLogOutDelay\" -ge 300 -a \"$AutoLogOutDelay\" -le 3600 ]; then\n    echo \"Enabing AutoLogOutDelay\"\nelif [ \"$AutoLogOutDelay\" -eq 0 ]; then\n    echo \"Disabling AutoLogOutDelay\"\nelse echo \"$AutoLogOutDelay is not a valid value. Set AutoLogOutDelay to a number between 300 and 3600 or 0 to disable\" exit 2; fi\n\nsudo defaults write /Library/Preferences/.GlobalPreferences.plist com.apple.autologout.AutoLogOutDelay -int $AutoLogOutDelay\nsleep 2\nsudo defaults read /Library/Preferences/.GlobalPreferences.plist com.apple.autologout.AutoLogOutDelay",
    "link": "https://github.com/TheJumpCloud/support/blob/master/PowerShell/JumpCloud%20Commands%20Gallery/Mac%20Commands/Mac%20-%20Set%20Auto%20Logout%20Delay.md",
    "description": "This command will enable the macOS setting to auto log out a machine after \"X\" minutes of inactivity.\n\nThe input variable for this command `AutoLogOutDelay` takes in a value between 300 and 3600 seconds.\nThis is represented in the System Preferences pane in minutes under the tab \"Security & Privacy\" > \"Advanced\" in the field \"Log out after X minutes of inactivity\".\n\nIf the value specified for the `AutoLogOutDelay` is set to 0 this will disable the setting and turn off the AutoLogOutDelay setting."
  },
  {
    "name": "Mac - Set Desktop Background | v2.1 JCCG",
    "type": "mac",
    "command": "## *** Customize ***\n  # 1. Update the 'backgroundURL' to the URL of your desired desktop image. A JumpCloud image is used by default.\n  backgroundURL=\"https://raw.githubusercontent.com/TheJumpCloud/support/master/PowerShell/JumpCloud%20Commands%20Gallery/Files/JumpCloud_Background.png\"\n  # 2. Ensure the 'fileType' matches the file type of the desktop image (change to jpg if using a jpg). 'png' is set by default.\n  fileType=\"png\"\n  # ------------Do not modify below this line-------------\n  date_val=$(date \"+%Y-%m-%d-%H%M\")\n  backgroundFile=/Users/Shared/desktopimage_$date_val.$fileType\n  curl -s -o \"$backgroundFile\" \"$backgroundURL\"\nread -r -d '' PSCRIPT<<EOF\nfrom AppKit import NSWorkspace, NSScreen\nfrom Foundation import NSURL\n# generate a fileURL for the desktop picture\nfile_url = NSURL.fileURLWithPath_('$backgroundFile')\n# make image options dictionary\n# we just make an empty one because the defaults are fine\noptions = {}\n# get shared workspace\nws = NSWorkspace.sharedWorkspace()\n# iterate over all screens\nfor screen in NSScreen.screens():\n    # tell the workspace to set the desktop picture\n    (result, error) = ws.setDesktopImageURL_forScreen_options_error_(\n                file_url, screen, options, None)\nEOF\n  env python -c \"$PSCRIPT\"",
    "link": "https://github.com/TheJumpCloud/support/blob/master/PowerShell/JumpCloud%20Commands%20Gallery/Mac%20Commands/Mac%20-%20Set%20Desktop%20Background.md",
    "description": "The \"JumpCloud_Background.png\" file is downloaded to the local machine and saved in the folder \"/Users/Shared\"/\n\nTo modify this command to download and set a background image of your choice follow the steps under '*** Customize ***' by updating the backgroundURL and corresponding fileType variables.\n\nThis command used in tandem with the wallpaper modification Mac policy can be used to set and then prevent end users from updating their background.\n\nThis command can be built manually as a Mac command where the 'run-as' user is set to the JC managed user on that machine and can not be executed as the root user."
  },
  {
    "name": "Windows - 64-Bit Command | v1.0 JCCG",
    "type": "windows",
    "command": "## Enter the command within the \"\" on the below line\n\n$64BitCommand = \"\"\n\n#------ Do not modify below this line ---------------\n\n& (Join-Path ($PSHOME -replace 'syswow64', 'sysnative') powershell.exe) -Command \"& {$64BitCommand}\"",
    "link": "https://github.com/TheJumpCloud/support/blob/master/PowerShell/JumpCloud%20Commands%20Gallery/Windows%20Commands/Windows%20-%2064-Bit%20Command.md",
    "description": "A template to use to execute PowerShell commands in the 64-bit environment. By default, all JumpCloud PowerShell commands are executed in the 32-bit PowerShell environment. Some commands are only available for execution in the 64-bit environment.\n\nTo determine if a command is 32 or 64-bit discovery can be done using the command Get-Command to find the module that a command is loaded in and then checking for that module in a 32-bit session.\n\nThe command Get-LocalUser is only available in the 64-bit environment.\n\nWe can see this by using the Get-Command function and passing in the Get-LocalUser command.\n\nExample\n\n```PowerShell\nGet-Command Get-LocalUser\n\nCommandType     Name                                               Version    Source\n-----------     ----                                               -------    ------\nCmdlet          Get-LocalUser                                      1.0.0.0    Microsoft.PowerShell.LocalAccounts\n\n```\n\nThe Get-LocalUser command shows the source of the Get-LocalUser command is the **Microsoft.PowerShell.LocalAccounts** module.\n\nWhen running Get-Module in the 32-bit environment, the output reveals that this module is not loaded and therefore any of the commands within the module are not accessible.\n\nExample from **32-bit shell:**\n\n```PowerShell\nGet-Module | Select-Object ModuleType, Version, Name\n\nModuleType Version Name\n---------- ------- ----\n  Manifest 3.1.0.0 Microsoft.PowerShell.Management\n  Manifest 3.1.0.0 Microsoft.PowerShell.Utility\n\n```\n\nWhen running the Get-Module command in the 64-bit environment we can see the **Microsoft.PowerShell.LocalAccounts**.\n\nExample from **64-bit shell:**\n\n```PowerShell\nGet-Module | Select-Object ModuleType, Version, Name\n\nModuleType Version        Name\n---------- -------        ----\n    Binary 1.0.0.0        Microsoft.PowerShell.LocalAccounts\n  Manifest 3.1.0.0        Microsoft.PowerShell.Management\n  Manifest 3.1.0.0        Microsoft.PowerShell.Utility\n```\n\nThis demonstrates why the Get-LoacalUser command must be called in a 64-bit environment as templated above by using the [sysnative folder](http://www.samlogic.net/articles/sysnative-folder-64-bit-windows.htm)."
  },
  {
    "name": "Windows - 64-Bit MultiLine Command | v1.0 JCCG",
    "type": "windows",
    "command": "## Enter your command within the @' '@\n## Use single quotes ' not double quotes \" for all variables\n## Example multi-line command below\n\n$64BitCommand = @'\n$Hello = 'Howdy'\n$World = 'World'\nWrite-Host \"Well $Hello $World\"\n'@\n\n#------ Do not modify below this line ---------------\n& (Join-Path ($PSHOME -replace 'syswow64', 'sysnative') powershell.exe) -Command \"& {$64BitCommand}\"",
    "link": "https://github.com/TheJumpCloud/support/blob/master/PowerShell/JumpCloud%20Commands%20Gallery/Windows%20Commands/Windows%20-%2064-Bit%20MultiLine%20Command.md",
    "description": "A template to use to execute a multiline PowerShell command in the 64-bit environment. By default, all JumpCloud PowerShell commands are executed in the 32-bit PowerShell environment. Some commands are only available for execution in the 64-bit environment.\n\nTo determine if a command is 32 or 64-bit discovery can be done using the command Get-Command to find the module that a command is loaded in and then checking for that module in a 32-bit session.\n\nThe command Get-LocalUser is only available in the 64-bit environment.\n\nWe can see this by using the Get-Command function and passing in the Get-LocalUser command.\n\nExample\n\n```PowerShell\nGet-Command Get-LocalUser\n\nCommandType     Name                                               Version    Source\n-----------     ----                                               -------    ------\nCmdlet          Get-LocalUser                                      1.0.0.0    Microsoft.PowerShell.LocalAccounts\n\n```\n\nThe Get-LocalUser command shows the source of the Get-LocalUser command is the **Microsoft.PowerShell.LocalAccounts** module.\n\nWhen running Get-Module in the 32-bit environment, the output reveals that this module is not loaded and therefore any of the commands within the module are not accessible.\n\nExample from **32-bit shell:**\n\n```PowerShell\nGet-Module | Select-Object ModuleType, Version, Name\n\nModuleType Version Name\n---------- ------- ----\n  Manifest 3.1.0.0 Microsoft.PowerShell.Management\n  Manifest 3.1.0.0 Microsoft.PowerShell.Utility\n\n```\n\nWhen running the Get-Module command in the 64-bit environment we can see the **Microsoft.PowerShell.LocalAccounts**.\n\nExample from **64-bit shell:**\n\n```PowerShell\nGet-Module | Select-Object ModuleType, Version, Name\n\nModuleType Version        Name\n---------- -------        ----\n    Binary 1.0.0.0        Microsoft.PowerShell.LocalAccounts\n  Manifest 3.1.0.0        Microsoft.PowerShell.Management\n  Manifest 3.1.0.0        Microsoft.PowerShell.Utility\n```\n\nThis demonstrates why the Get-LoacalUser command must be called in a 64-bit environment as templated above by using the [sysnative folder](http://www.samlogic.net/articles/sysnative-folder-64-bit-windows.htm)."
  },
  {
    "name": "Windows - AppX Removal Startup Script | v1.0 JCCG",
    "type": "windows",
    "command": "$Ps1FileName = 'AppXRemoval_Win10.ps1'\n\n$Ps1ScriptBody = @\"\n# Apps to remove\n`$appname = @(\n'*Microsoft.BingFinance*'\n'*Microsoft.SkypeApp*'\n'*Twitter*'\n'*Microsoft.3DBuilder*'\n'*king.com.CandyCrushSodaSaga*'\n'*Microsoft.BingNews*'\n'*Microsoft.WindowsMaps*'\n'*Microsoft.BingSports*'\n'*Microsoft.Office.OneNote*'\n'*Microsoft.MicrosoftSolitaireCollection*'\n'*Microsoft.WindowsAlarms*'\n'*Microsoft.BingWeather*'\n'*Microsoft.XboxApp*'\n)\n# Removes the above apps\nForEach(`$app in `$appname){\n    Get-AppxPackage -Name `$app | Remove-AppxPackage -ErrorAction SilentlyContinue\n}\n\n# Deletes the .bat and the .ps1  \nRemove-Item -Path \"`$env:USERPROFILE\\AppData\\Roaming\\Microsoft\\Windows\\Start Menu\\Programs\\startup\\LogOn.bat\"  -Force\nRemove-Item -Path \"`$env:USERPROFILE\\AppData\\local\\AppXRemoval_Win10.ps1\"  -Force\n\"@\n\n$BatBody = @\" \n@echo off\nstart Powershell.exe -executionpolicy remotesigned -windowstyle hidden -File  %userprofile%\\AppData\\Local\\AppXRemoval_Win10.ps1 /min\n\"@\n\n# Gets all of our users excluding Public user\n$users = Get-ChildItem -Path \"C:\\Users\" | ? {$_.Name -NE 'Public'} \n\n# Add files in all users /local and /Startup folder\nforeach($user in $users){\n\nNew-Item -Path \"C:\\Users\\$($user.name)\\AppData\\local\" -Name $Ps1FileName  -ItemType \"file\" -Value $Ps1ScriptBody \n\nNew-Item -Path \"C:\\Users\\$($user.name)\\AppData\\Roaming\\Microsoft\\Windows\\Start Menu\\Programs\\Startup\" -Name \"LogOn.bat\" -ItemType \"file\" -Value $BatBody\n\n}",
    "link": "https://github.com/TheJumpCloud/support/blob/master/PowerShell/JumpCloud%20Commands%20Gallery/Windows%20Commands/Windows%20-%20AppX%20Removal%20Startup%20Script.md",
    "description": "AppX applications are installed per user on a Windows machine. This command creates a .ps1 script and .bat file within each users profile where the payload of the .ps1 script uninstalls the listed AppX packages. Admins can add or remove AppX apps for the script to uninstall by modifying the $appname array.\n\nFind more info on removing AppX pacakages [here](https://www.pdq.com/blog/remove-appx-packages/#)"
  },
  {
    "name": "Windows - Change Lock Screen & Desktop Background | v1.0 JCCG",
    "type": "windows",
    "command": "# Replace these variable sources with actual values:\n$LockScreenSource = 'C:\\pathToImages\\lockImage.jpg'\n$BackgroundSource = 'C:\\pathToImages\\backgroundImage.jpg'\n\nFunction Update-LockAndBackgroundScreen{\n    Param(\n            [Parameter(Mandatory=$false,Position=0)]\n            [ValidateNotNullOrEmpty()]\n            [string]$LockScreenSource,\n            [Parameter(Mandatory=$false,Position=1)]\n            [ValidateNotNullOrEmpty()]\n            [string]$BackgroundSource\n    )\n    Begin {\n        $ErrorActionPreference = \"Stop\"\n        $RegKeyPath = \"HKLM:\\SOFTWARE\\Microsoft\\Windows\\CurrentVersion\\PersonalizationCSP\"\n        $DesktopPath = \"DesktopImagePath\"\n        $DesktopStatus = \"DesktopImageStatus\"\n        $DesktopUrl = \"DesktopImageUrl\"\n        $LockScreenPath = \"LockScreenImagePath\"\n        $LockScreenStatus = \"LockScreenImageStatus\"\n        $LockScreenUrl = \"LockScreenImageUrl\"\n        $StatusValue = \"1\"\n        $DesktopImageValue = \"C:\\Windows\\System32\\Desktop.jpg\"\n        $LockScreenImageValue = \"C:\\Windows\\System32\\LockScreen.jpg\"\n    }\n    process{\n        if (!$LockScreenSource -and !$BackgroundSource)\n        {\n            Write-Host \"Either LockScreenSource or BackgroundSource must has a value.\"\n        }\n        else\n        {\n            if(!(Test-Path $RegKeyPath)) {\n                Write-Host \"Creating registry path $($RegKeyPath).\"\n                New-Item -Path $RegKeyPath -Force | Out-Null\n            }\n            if ($LockScreenSource) {\n                Write-Host \"Copy Lock Screen image from $($LockScreenSource) to $($LockScreenImageValue).\"\n                Copy-Item $LockScreenSource $LockScreenImageValue -Force\n                Write-Host \"Creating registry entries for Lock Screen\"\n                New-ItemProperty -Path $RegKeyPath -Name $LockScreenStatus -Value $StatusValue -PropertyType DWORD -Force | Out-Null\n                New-ItemProperty -Path $RegKeyPath -Name $LockScreenPath -Value $LockScreenImageValue -PropertyType STRING -Force | Out-Null\n                New-ItemProperty -Path $RegKeyPath -Name $LockScreenUrl -Value $LockScreenImageValue -PropertyType STRING -Force | Out-Null\n            }\n            if ($BackgroundSource) {\n                Write-Host \"Copy Desktop Background image from $($BackgroundSource) to $($DesktopImageValue).\"\n                Copy-Item $BackgroundSource $DesktopImageValue -Force\n                Write-Host \"Creating registry entries for Desktop Background\"\n                New-ItemProperty -Path $RegKeyPath -Name $DesktopStatus -Value $StatusValue -PropertyType DWORD -Force | Out-Null\n                New-ItemProperty -Path $RegKeyPath -Name $DesktopPath -Value $DesktopImageValue -PropertyType STRING -Force | Out-Null\n                New-ItemProperty -Path $RegKeyPath -Name $DesktopUrl -Value $DesktopImageValue -PropertyType STRING -Force | Out-Null\n            }\n            rundll32.exe user32.dll, UpdatePerUserSystemParameters\n        }\n    }\n}\n\n\nUpdate-LockAndBackgroundScreen -LockScreenSource $LockScreenSource -BackgroundSource $BackgroundSource",
    "link": "https://github.com/TheJumpCloud/support/blob/master/PowerShell/JumpCloud%20Commands%20Gallery/Windows%20Commands/Windows%20-%20Change%20Lock%20Screen%20%26%20Desktop%20Background.md",
    "description": "Change Lock Screen and Desktop Background in Windows 10 Pro. This script allows you to change logon screen and desktop background in Windows 10 Professional using GPO startup script. The Update-LockAndBackgroundScreen function takes two parameter sources, LockScreenSource & BackgroundSource. One or both parameters may be used to update the lock and desktop background. This script was modified from author: Juan Granados and originally posted at: https://gallery.technet.microsoft.com/scriptcenter/Change-Lock-Screen-and-245b63a0#content\n\nThis command can be used in conjunction with files uploaded directly to JumpCloud. Both the lock screen and desktop background images can be uploaded to systems as long as the file destination folder exists on the target system. In the example below the target system contained an 'images' directory in C:\\ prior to running the command.\n\n![wallpaper image](../Files/wallpaperImage.png)"
  },
  {
    "name": "Windows - Disable Local User | v1.0 JCCG",
    "type": "windows",
    "command": "################################################################################\n# This script will disable the *matched* username patterns in the usersToMatch\n# list variable. For Example:\n# Users on the system: administrator, steve, it-staff\n# $usersToMatch = @(\"admin\", \"it\")\n# both the administrator and it-staff would be disabled\n# - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -\n# Test how this command will run by setting the disable variable to false. When\n# set to false the script will identify users to disable and print out a list\n# without disabling the accounts\n################################################################################\n\n# Settings, set $true or $false\n$disable = $true\n\n# Enter user(s) patterns you want to match against (user admin bobsAccount)\n$usersToMatch = @(\"admin\", \"it\")\n\n# Do not modify below this line\n################################################################################\n\n$regexPattern=\"\"\n$last = [int]($usersToMatch.Length) - 1\nforeach ($user in $usersToMatch) {\n    Write-Host $user\n    if ($user -eq $usersToMatch[$last]){\n        $regexpattern += \"$($user)[^\\s]*\"\n    }\n    else{\n        $regexpattern += \"$($user)[^\\s]*|\"\n    }\n}\nWrite-Host \"Searching System for the following users: $usersToMatch\"\nWrite-Host \"Regex Pattern: $regexPattern\"\n\n$localUsers = Get-LocalUser\n$foundUsers = @()\nforeach ($username in $localUsers.name)\n{\n    if ($username -match $regexPattern)\n    {\n        # Set Selected Username Variable\n        write-host \"Matched $username user found\"\n        $foundUsers += $username\n    }\n}\n\nWrite-Host \"The Following users will be disabled: $foundUsers\"\n$loggedInUsers=query user\nforeach ($username in $foundUsers){\n    if ($disable){\n        if ($loggedInUsers -match $username) {\n            Write-Host \"Logging $username out of system\"\n            $session = quser | Where-Object { $_ -match $username }\n            ## Parse the session IDs from the output\n            $sessionIds = ($session -split ' +')[2]\n            Write-Host \"Found $sessionIds for $username on system.\"\n            ## Loop through each session ID and pass each to the logoff command\n            $sessionIds | ForEach-Object {\n                Write-Host \"Logging off session id [$($_)]...\"\n                logoff $_\n            }\n        }\n        Disable-LocalUser -Name $username\n    }\n}",
    "link": "https://github.com/TheJumpCloud/support/blob/master/PowerShell/JumpCloud%20Commands%20Gallery/Windows%20Commands/Windows%20-%20Disable%20Local%20User.md",
    "description": "This command will disable the local users that match the regex pattern supplied in the 'usersToMatch' list variable. If for example, a system contains the following users:\n\nSteve, Administrator, IT-Admin\n\nAnd the $usersToMatch variable is set to (\"admin\", \"it\"), both the 'Administrator' and 'IT-Admin' Account would be disabled. The Regex pattern searches usernames for partial matches.\n\nRun this script with disable=false to test what accounts would be disabled before running disable=true."
  },
  {
    "name": "Windows - Enable Task Scheduler History | v1.0 JCCG",
    "type": "windows",
    "command": "## Enables the windows event log for the task scheduler\n## Equivalent to checking the box \"Enable All Task History\" within task scheduler\n\n$TaskScheduler = 'Microsoft-Windows-TaskScheduler/Operational'\n$TaskSchedulerLog = New-Object System.Diagnostics.Eventing.Reader.EventLogConfiguration $TaskScheduler\n$TaskSchedulerLog.IsEnabled = $true\n$TaskSchedulerLog.SaveChanges()",
    "link": "https://github.com/TheJumpCloud/support/blob/master/PowerShell/JumpCloud%20Commands%20Gallery/Windows%20Commands/Windows%20-%20Enable%20Task%20Scheduler%20History.md",
    "description": "This command will enable windows task schedule history on remote systems."
  },
  {
    "name": "Windows - Exclude JCAgent from Windows Defender | v1.0 JCCG",
    "type": "windows",
    "command": "$64BitCommand = \"Add-MpPreference -ExclusionPath 'C:\\Program Files (x86)\\JumpCloud\\jumpcloud-agent.exe'\"\n\n& (Join-Path ($PSHOME -replace 'syswow64', 'sysnative') powershell.exe) -Command \"& {$64BitCommand}\"",
    "link": "https://github.com/TheJumpCloud/support/blob/master/PowerShell/JumpCloud%20Commands%20Gallery/Windows%20Commands/Windows%20-%20Exclude%20JCAgent%20from%20Windows%20Defender.md",
    "description": "This command will remove the jumpcloud-agent.exe from Windows Defender scheduled and real-time scanning.\n\nThe command Add-MpPreference is only available in the 64-bit environment and the JumpCloud agent operates in the 32-bit environment which is why sysnative is used."
  },
  {
    "name": "Windows - Get Installed PowerShell Version | v1.0 JCCG",
    "type": "windows",
    "command": "$PSVersionTable",
    "link": "https://github.com/TheJumpCloud/support/blob/master/PowerShell/JumpCloud%20Commands%20Gallery/Windows%20Commands/Windows%20-%20Get%20Installed%20PowerShell%20version.md",
    "description": "The $PSVersionTable variable was first introduced in PowerShell version 2.0. The $PSVersionTable lists the version of PowerShell installed (\u201cPSVersion\u201d) and related components."
  },
  {
    "name": "Windows - Get JCagent.log | v1.0 JCCG",
    "type": "windows",
    "command": "Get-content -Path 'C:\\Windows\\Temp\\jcagent.log'",
    "link": "https://github.com/TheJumpCloud/support/blob/master/PowerShell/JumpCloud%20Commands%20Gallery/Windows%20Commands/Windows%20-%20Get%20JCagent.log.md",
    "description": "Returns the jcagent.log from a Windows system. If the jcagent.log is larger than 1 MB the most recend 1 MB of data from the log will be returned."
  },
  {
    "name": "Windows - Get Logged In User | v1.0 JCCG",
    "type": "windows",
    "command": "Get-WMIObject -class Win32_ComputerSystem | select-object -expandproperty username",
    "link": "https://github.com/TheJumpCloud/support/blob/master/PowerShell/JumpCloud%20Commands%20Gallery/Windows%20Commands/Windows%20-%20Get%20Logged%20In%20User.md",
    "description": "Get current logged in user"
  },
  {
    "name": "Windows - Get OS Name and Version | v1.0 JCCG",
    "type": "windows",
    "command": "$sys = (systeminfo /fo csv | ConvertFrom-Csv)\nreturn \"HostName: \" + ($sys.'Host Name') + \"`n\" + \"OS Name: \" + ($sys.'OS Name') + \"`n\" + \"OS Version: \" +($sys.'OS Version')",
    "link": "https://github.com/TheJumpCloud/support/blob/master/PowerShell/JumpCloud%20Commands%20Gallery/Windows%20Commands/Windows%20-%20Get%20OS%20Name%20and%20Version.md",
    "description": "Returns the hostname, OS Name, and OS Version including build number of a Windows host."
  },
  {
    "name": "Windows - Get Service Account Logon Attempts | v1.0 JCCG",
    "type": "windows",
    "command": "## Enter the date range to search on the lines below\n\n$StartTime = '11/05/2020 08:00:00'\n$EndTime = '11/05/2020 08:20:00'\n$EventIdFilter = ('4624', '4625')\n\n#------ Do not modify below this line ---------------\n\n$Events = Get-WinEvent -FilterHashtable @{ LogName = 'Security'; Id = $EventIdFilter; StartTime = $StartTime; EndTime = $EndTime; } | Where-Object { $_.Message | Select-String -Pattern:('(Logon Type:)(.*?)(5)') } | Sort-Object CreatedTimestamp\n$Events | ForEach-Object {\n    [PSCustomObject]@{\n        Type          = Switch ($_.Id) { '4624' { 'Login Success' } '4625' { 'Login Failure' } }\n        MachineName   = $_.MachineName\n        TimeCreated   = $_.TimeCreated\n        ElevatedToken = ($_.Message | Select-String -Pattern:('(Elevated Token:)(.*?)(\\n)')).Matches.Value.Replace('Elevated Token:', '').Trim()\n        AccountName   = ($_.Message | Select-String -AllMatches -Pattern:('(Account Name:)(.*?)(\\n)')).Matches.Value[1].Replace('Account Name:', '').Trim()\n        AccountDomain   = ($_.Message | Select-String -AllMatches -Pattern:('(Account Domain:)(.*?)(\\n)')).Matches.Value[1].Replace('Account Domain:', '').Trim()\n        ProcessName   = ($_.Message | Select-String -Pattern:('(Process Name:)(.*?)(\\n)')).Matches.Value.Replace('Process Name:', '').Trim()\n    }\n}",
    "link": "https://github.com/TheJumpCloud/support/blob/master/PowerShell/JumpCloud%20Commands%20Gallery/Windows%20Commands/Windows%20-%20Get%20Service%20Account%20Logon%20Attempts.md",
    "description": "Running this command will return events generated for when the Logon Title is **SERVICE** when a logon session is created or if an account logon attempt failed when the account was already locked out.\n\nThe command returns:\n```\nType          : Login Success\nMachineName   : My-Windows-PC\nTimeCreated   : 11/5/2020 08:01:55\nElevatedToken : Yes\nAccountName   : SYSTEM\nAccountDomain : NT AUTHORITY\nProcessName   : C:\\Windows\\System32\\services.exe\n\nType          : Login Success\nMachineName   : My-Windows-PC\nTimeCreated   : 11/5/2020 08:14:59\nElevatedToken : Yes\nAccountName   : SYSTEM\nAccountDomain : NT AUTHORITY\nProcessName   : C:\\Windows\\System32\\services.exe\n```\n\nFor more details about these event records see:\n* https://docs.microsoft.com/en-us/windows/security/threat-protection/auditing/event-4624\n* https://docs.microsoft.com/en-us/windows/security/threat-protection/auditing/event-4625"
  },
  {
    "name": "Windows - Get Windows Cached Credentials | v1.0 JCCG",
    "type": "windows",
    "command": "function Test-ServiceForUserAccount {\n    param (\n        $StartName\n    )\n\n    if (-not $StartName) {\n        $false\n        return\n    }\n\n    $AccountName = $StartName.Trim().ToLower()\n\n    if (-not $AccountName) {\n        $false\n        return\n    }\n    if ($AccountName -eq 'localsystem') {\n        $false\n        return\n    }\n    if ($AccountName.StartsWith('nt authority\\')) {\n        $false\n        return\n    }\n\n    $true\n}\n\nfunction Write-ServiceInfos {\n    param (\n        [Parameter(ValueFromPipeline)]\n        [object[]]\n        $ServiceInfos\n    )\n\n    BEGIN {}\n\n    PROCESS {\n        foreach ($ServiceInfo in $ServiceInfos) {\n            Write-Output('')\n            Write-Output('    Name: ' + $ServiceInfo.Name)\n            Write-Output('    PathName: ' + $ServiceInfo.PathName)\n            Write-Output('    StartMode: ' + $ServiceInfo.StartMode)\n            Write-Output('    State: ' + $ServiceInfo.State)\n            Write-Output('    ProcessId: ' + $ServiceInfo.ProcessId)\n            Write-Output('    StartName: ' + $ServiceInfo.StartName)\n        }\n    }\n    END {}\n}\n\nfunction Test-TaskForUserAccount {\n    param (\n        $Principal\n    )\n\n    if (($Principal.LogonType -eq 'Password') -or ($Principal.LogonType -eq 'InteractiveOrPassword')) {\n\n        if (!($Principal.userid) -or ($Principal.userid -eq \"SYSTEM\") -or ($Principal.userid -eq \"LOCAL SERVICE\") -or ($Principal.userid -eq \"NETWORK SERVICE\")) {\n            $false\n            return\n        }\n\n        $true\n        return\n\n    }\n\n    $false\n}\n\nfunction Write-TaskInfos {\n    param (\n        [Parameter(ValueFromPipeline)]\n        [object[]]\n        $TaskInfos\n    )\n\n    BEGIN {}\n\n    PROCESS {\n        foreach ($TaskInfo in $TaskInfos) {\n            Write-Output('')\n            Write-Output('    TaskName: ' + $TaskInfo.TaskName)\n            Write-Output('    UserId: ' + $TaskInfo.Principal.UserId)\n            Write-Output('    LogonType: ' + $TaskInfo.Principal.LogonType)\n            Write-Output('    Execute: ' + [System.IO.Path]::GetFileName([System.Environment]::ExpandEnvironmentVariables($TaskInfo.Actions.Execute).Trim('\"')))\n            Write-Output('    Arguments: ' + [System.Environment]::ExpandEnvironmentVariables($TaskInfo.Actions.Arguments))\n        }\n    }\n    END {}\n}\n\nWrite-Output('Services that run in a user account context:')\nGet-WmiObject Win32_Service | Where { Test-ServiceForUserAccount($_.startname) } | Write-ServiceInfos\n\nWrite-Output('')\nWrite-Output('Scheduled tasks that run in a user account context:')\nGet-ScheduledTask | Where { Test-TaskForUserAccount($_.Principal) } | Write-TaskInfos\n\n& cmdkey.exe /list",
    "link": "https://github.com/TheJumpCloud/support/blob/master/PowerShell/JumpCloud%20Commands%20Gallery/Windows%20Commands/Windows%20-%20Get%20Windows%20Cached%20Credentials.md",
    "description": "Executes a script to help identify Windows services, scheduled tasks, or third-party applications that use stored credentials and may potentially cause lockouts if the credentials get stale, usually after password changes."
  },
  {
    "name": "Windows - Get Windows Defender Settings | v1.0 JCCG",
    "type": "windows",
    "command": "$64BitCommand = \"Get-MpPreference\"\n\n& (Join-Path ($PSHOME -replace 'syswow64', 'sysnative') powershell.exe) -Command \"& {$64BitCommand}\"",
    "link": "https://github.com/TheJumpCloud/support/blob/master/PowerShell/JumpCloud%20Commands%20Gallery/Windows%20Commands/Windows%20-%20Get%20Windows%20Defender%20Settings.md",
    "description": "This command will return the Window Defender Exclusion settings\n\nThe command Get-MpPreference is only available in the 64-bit environment and the JumpCloud agent operates in the 32-bit environment which is why sysnative is used."
  },
  {
    "name": "Windows - Install CrowdStrike Falcon Agent | v2.0 JCCG",
    "type": "windows",
    "command": "$CSBaseAddress = \"\"\n$CSClientID = \"\"\n$CSClientSecret = \"\"\n\n# Installation Token (Only use if you have Require Tokens enabled for your organization)\n# https://falcon.us-2.crowdstrike.com/documentation/page/f8a0f751/host-and-host-group-management#x7be77b4\n\n$CSInstallToken=\"\"\n\n############### Do Not Edit Below This Line ###############\nfunction Connect-CrowdStrike {\n    param(\n        [Parameter(Position = 1)]\n        [ValidateSet('https://api.crowdstrike.com', 'https://api.us-2.crowdstrike.com',\n            'https://api.eu-1.crowdstrike.com', 'https://api.laggar.gcw.crowdstrike.com')]\n        [string] $CSBaseAddress,\n\n        [Parameter(Position = 2)]\n        [ValidatePattern('\\w{32}')]\n        [string] $CSClientId,\n\n        [Parameter(Position = 3)]\n        [ValidatePattern('\\w{40}')]\n        [string] $CSClientSecret\n    )\n    begin {\n        $ApiBody = @{\n            \"client_id\"     = $CSClientId\n            \"client_secret\" = $CSClientSecret\n        }\n        $Headers = @{\n            \"Accept\"       = \"application/json\";\n            \"Content-Type\" = \"application/x-www-form-urlencoded\"\n        }\n        $global:CSBaseAddress = $CSBaseAddress\n    }\n    process {\n        $Response = Invoke-WebRequest -Uri \"$CSBaseAddress/oauth2/token\" -Method Post -Headers $Headers -Body $ApiBody -UseBasicParsing\n\n        if ($Response.headers.\"X-Ratelimit-Remaining\" -le 0) {\n            Write-Host \"Too many requests are being made to CrowdStrike services...\"\n            exit 429\n        }\n        if ($Response.StatusCode -eq 201) {\n            Write-Host \"Successfully authenticated; Access Token created\"\n            $CrowdStrikeAccessToken = [regex]::Matches($Response.Content, '\"(?<name>access_token)\": \"(?<access_token>.*)\",')[0].Groups['access_token'].Value\n            $global:CrowdStrikeAccessToken = $CrowdStrikeAccessToken\n        }\n    }\n}\nfunction Get-CrowdStrikeCcid {\n    begin {\n        $CrowdStrikeAuthHeader = @{\n            \"Authorization\" = \"bearer $CrowdStrikeAccessToken\"\n            \"Accept\"        = \"application/json\"\n        }\n    }\n    process {\n        $Response = Invoke-WebRequest -Uri \"$CSBaseAddress/sensors/queries/installers/ccid/v1\" -method Get -Headers $CrowdStrikeAuthHeader -UseBasicParsing\n\n        if ($Response.headers.\"X-Ratelimit-Remaining\" -le 0) {\n            Write-Host \"Too many requests are being made to CrowdStrike services...\"\n            exit 429\n        }\n\n        $Ccid = [regex]::Matches($Response, '(?<ccid>\\w{32}-\\w{2})')[0].Groups['ccid'].Value\n    }\n    end {\n        return $Ccid\n    }\n}\n\nfunction Get-CrowdStrikeSensorInstaller {\n    param (\n        [Parameter(Position = 1)]\n        [ValidateSet('windows')]\n        [string] $operatingSystem\n    )\n    begin {\n        $CrowdStrikeAuthHeader = @{\n            \"Authorization\" = \"bearer $CrowdStrikeAccessToken\"\n            \"Accept\"        = \"application/json\"\n        }\n    }\n    process {\n        $Response = Invoke-WebRequest -Uri \"$CSBaseAddress/sensors/combined/installers/v1\" -method Get -Headers $CrowdStrikeAuthHeader -UseBasicParsing\n\n        if ($Response.headers.\"X-Ratelimit-Remaining\" -le 0) {\n            Write-Host \"Too many requests are being made to CrowdStrike services...\"\n            exit 429\n        }\n\n        $Installers = $Response.Content | ConvertFrom-Json\n        $Installers = $Installers.Resources | Group-Object platform\n\n        switch ($operatingSystem) {\n            windows {\n                $WindowsInstallers = $Installers | Where-Object Name -eq 'windows'\n                $SortedInstallers = $WindowsInstallers.Group | Sort-Object release_date -Descending\n            }\n        }\n        $LatestInstaller = $SortedInstallers | Select-Object -First 1\n    }\n    end {\n        return $LatestInstaller\n    }\n}\n\ntry {\n    Write-Host \"Connecting to CrowdStrike Tenant...\"\n    Connect-CrowdStrike -CSBaseAddress $CSBaseAddress -CSClientId $CSClientId -CSClientSecret $CSClientSecret\n} catch {\n    Write-Error \"Unable to connect to CrowdStrike...\"\n    exit 1\n}\n\nWrite-Host \"Gathering CCID information...\"\n$CID = Get-CrowdStrikeCcid\n\nWrite-Host \"Finding latest Windows installer...\"\n$LatestInstaller = Get-CrowdStrikeSensorInstaller -operatingSystem 'windows'\n\n$installerURL = \"$CSBaseAddress/sensors/entities/download-installer/v1?id=$($LatestInstaller.sha256)\"\n$CrowdStrikeAuthHeader = @{\n    \"Authorization\" = \"bearer $CrowdStrikeAccessToken\"\n    \"Accept\"        = \"application/octet-stream\"\n}\n\n$installerTempLocation = \"C:\\Windows\\Temp\\CSFalconAgentInstaller.exe\"\n\nif (Get-Service \"CSFalconService\" -ErrorAction SilentlyContinue) {\n    Write-Host \"Falcon Agent already installed, nothing to do.\"\n    exit 0\n}\nWrite-Host \"Falcon Agent not installed.\"\n\nWrite-Host \"Downloading Falcon Agent installer now.\"\ntry {\n    $ProgressPreference = 'SilentlyContinue'\n    Invoke-WebRequest -Headers $CrowdStrikeAuthHeader -Uri $installerURL -UseBasicParsing -OutFile $installerTempLocation\n} catch {\n    Write-Error \"Unable to download Falcon Agent installer.\"\n    exit 1\n}\nWrite-Host \"Finished downloading Falcon Agent installer.\"\n\nWrite-Host \"Installing Falcon Agent now, this may take a few minutes.\"\ntry {\n    $args = @(\"/install\", \"/quiet\", \"/norestart\", \"CID=$CID\")\n    if ($CSInstallToken){\n        $args += \"ProvToken=$CSInstallToken\"\n    }\n    $installerProcess = Start-Process -FilePath $installerTempLocation -Wait -PassThru -ArgumentList $args\n} catch {\n    Write-Error \"Failed to run Falcon Agent installer.\"\n    exit 1\n}\nWrite-Host \"Falcon Agent installer returned $($installerProcess.ExitCode).\"\n\nexit $installerProcess.ExitCode",
    "link": "https://github.com/TheJumpCloud/support/blob/master/PowerShell/JumpCloud%20Commands%20Gallery/Windows%20Commands/Windows%20-%20Install%20CrowdStrike%20Falcon%20Agent.md",
    "description": "This command will download and install the CrowdStrike Falcon Agent to the device if it isn't already installed. The command will leverage CrowdStrike's API to find and download the latest version of the Falcon Agent onto the local machine.\n\nFollow the instructions from the [Installing the CrowdStrike Falcon Agent KB](https://support.jumpcloud.com/s/article/Installing-the-Crowdstrike-Falcon-Agent#InstallWindows)\n\nIn order to use this command:\n\n1. Create a CrowdStrike API Client with the \"SENSOR DOWNLOAD\" Read scope and make note of the ClientID and ClientSecret Refer to CrowdStrike's article [Getting Access to the CrowdStrike API](https://www.crowdstrike.com/blog/tech-center/get-access-falcon-apis/) for further information\n2. Set the 3 variables (CSBaseAddress, CSClientID, CSClientSecret) to their respective values for your CrowdStrike API Client\n3. Extend the command timeout to a value that makes sense in your environment. The suggested command timeout for an environment with average network speeds on devices with average computing power is 10 minutes. Note that the command may timeout with a 124 error code in the command result window if not extended, but the script will continue to run."
  },
  {
    "name": "Windows - Install JumpCloud Password Manager App | v1.2 JCCG",
    "type": "windows",
    "command": "# Set $LaunchPasswordManager to $false  ON LINE 63 if you do not wish to launch the password manger after installation\n\n# Get the current logged on User\n$loggedUser = Get-WmiObject -Class Win32_ComputerSystem | Select-Object -ExpandProperty UserName\n$loggedUser = $loggedUser -replace '.*\\\\'\n\n# Construct the Registry path using the user's SID\n$userSID = (New-Object System.Security.Principal.NTAccount($loggedUser)).Translate([System.Security.Principal.SecurityIdentifier]).Value\n$registryPath = \"HKLM:\\SOFTWARE\\Microsoft\\Windows NT\\CurrentVersion\\ProfileList\\$userSID\"\n\n# Get the ProfileImagePath value from the Registry\n$loggedOnUserProfileImagePath = Get-ItemPropertyValue -Path $registryPath -Name 'ProfileImagePath'\nWrite-Output \"Logged On User Profile Path: $loggedOnUserProfileImagePath\"\n\n\n$installerURL = 'https://cdn.pwm.jumpcloud.com/DA/release/JumpCloud-Password-Manager-latest.exe'\nif (Test-Path \"$loggedOnUserProfileImagePath\\AppData\\Local\\Temp\" ) {\n\n    $installerTempLocation = \"$loggedOnUserProfileImagePath\\AppData\\Local\\Temp\\JumpCloud-Password-Manager-latest.exe\"\n    Write-Output \"Installer Location: $installerTempLocation\"\n}\nelse {\n    Write-Output \"Unable to determine user profile folder\"\n    Exit 1\n}\n\nWrite-Output 'Testing if Password Manager installer is downloaded'\n\nif (-not(Test-Path -Path $installerTempLocation -PathType Leaf)) {\n    try {\n        Write-Output 'Downloading Password Manager installer now.'\n        try {\n            Invoke-WebRequest -Uri $installerURL -OutFile $installerTempLocation\n        } catch {\n            Write-Error \"Unable to download Password Manager installer to $InstallerTempLocation.\"\n            exit 1\n        }\n        Write-Output 'Finished downloading Password Manager installer.'\n    } catch {\n        throw $_.Exception.Message\n    }\n}\n\nWrite-Output 'Installing Password Manager now, this may take a few minutes.'\n\n$Command = {\n    # Get the current user's SID (Security Identifier)\n    $loggedUser = Get-WmiObject -Class Win32_ComputerSystem | Select-Object -ExpandProperty UserName\n    $loggedUser = $loggedUser -replace '.*\\\\'\n\n    # Construct the Registry path using the user's SID\n    $userSID = (New-Object System.Security.Principal.NTAccount($loggedUser)).Translate([System.Security.Principal.SecurityIdentifier]).Value\n    $registryPath = \"HKLM:\\SOFTWARE\\Microsoft\\Windows NT\\CurrentVersion\\ProfileList\\$userSID\"\n    $loggedOnUserProfileImagePath = Get-ItemPropertyValue -Path $registryPath -Name 'ProfileImagePath'\n    $LaunchPasswordManager = $true\n    $installerTempLocation = \"$loggedOnUserProfileImagePath\\AppData\\Local\\Temp\\JumpCloud-Password-Manager-latest.exe\"\n    . $installerTempLocation\n    if ($LaunchPasswordManager -eq $true) {\n        while (!(Test-Path \"$loggedOnUserProfileImagePath\\AppData\\Local\\jcpwm\\JumpCloud Password Manager.exe\")) {\n            Start-Sleep 10\n        }\n        try {\n            . \"$loggedOnUserProfileImagePath\\AppData\\Local\\jcpwm\\JumpCloud Password Manager.exe\"\n\n        } catch {\n            throw $_.Exception.Message\n        }\n    }\n}\n\n$Source = @'\nusing System;\nusing System.Runtime.InteropServices;\n\nnamespace murrayju.ProcessExtensions\n{\n   public static class ProcessExtensions\n   {\n       #region Win32 Constants\n\n       private const int CREATE_UNICODE_ENVIRONMENT = 0x00000400;\n       private const int CREATE_NO_WINDOW = 0x08000000;\n\n       private const int CREATE_NEW_CONSOLE = 0x00000010;\n\n       private const uint INVALID_SESSION_ID = 0xFFFFFFFF;\n       private static readonly IntPtr WTS_CURRENT_SERVER_HANDLE = IntPtr.Zero;\n\n       #endregion\n\n       #region DllImports\n\n       [DllImport(\"advapi32.dll\", EntryPoint = \"CreateProcessAsUser\", SetLastError = true, CharSet = CharSet.Ansi, CallingConvention = CallingConvention.StdCall)]\n       private static extern bool CreateProcessAsUser(\n           IntPtr hToken,\n           String lpApplicationName,\n           String lpCommandLine,\n           IntPtr lpProcessAttributes,\n           IntPtr lpThreadAttributes,\n           bool bInheritHandle,\n           uint dwCreationFlags,\n           IntPtr lpEnvironment,\n           String lpCurrentDirectory,\n           ref STARTUPINFO lpStartupInfo,\n           out PROCESS_INFORMATION lpProcessInformation);\n\n       [DllImport(\"advapi32.dll\", EntryPoint = \"DuplicateTokenEx\")]\n       private static extern bool DuplicateTokenEx(\n           IntPtr ExistingTokenHandle,\n           uint dwDesiredAccess,\n           IntPtr lpThreadAttributes,\n           int TokenType,\n           int ImpersonationLevel,\n           ref IntPtr DuplicateTokenHandle);\n\n       [DllImport(\"userenv.dll\", SetLastError = true)]\n       private static extern bool CreateEnvironmentBlock(ref IntPtr lpEnvironment, IntPtr hToken, bool bInherit);\n\n       [DllImport(\"userenv.dll\", SetLastError = true)]\n       [return: MarshalAs(UnmanagedType.Bool)]\n       private static extern bool DestroyEnvironmentBlock(IntPtr lpEnvironment);\n\n       [DllImport(\"kernel32.dll\", SetLastError = true)]\n       private static extern bool CloseHandle(IntPtr hSnapshot);\n\n       [DllImport(\"kernel32.dll\")]\n       private static extern uint WTSGetActiveConsoleSessionId();\n\n       [DllImport(\"Wtsapi32.dll\")]\n       private static extern uint WTSQueryUserToken(uint SessionId, ref IntPtr phToken);\n\n       [DllImport(\"wtsapi32.dll\", SetLastError = true)]\n       private static extern int WTSEnumerateSessions(\n           IntPtr hServer,\n           int Reserved,\n           int Version,\n           ref IntPtr ppSessionInfo,\n           ref int pCount);\n\n       #endregion\n\n       #region Win32 Structs\n\n       private enum SW\n       {\n           SW_HIDE = 0,\n           SW_SHOWNORMAL = 1,\n           SW_NORMAL = 1,\n           SW_SHOWMINIMIZED = 2,\n           SW_SHOWMAXIMIZED = 3,\n           SW_MAXIMIZE = 3,\n           SW_SHOWNOACTIVATE = 4,\n           SW_SHOW = 5,\n           SW_MINIMIZE = 6,\n           SW_SHOWMINNOACTIVE = 7,\n           SW_SHOWNA = 8,\n           SW_RESTORE = 9,\n           SW_SHOWDEFAULT = 10,\n           SW_MAX = 10\n       }\n\n       private enum WTS_CONNECTSTATE_CLASS\n       {\n           WTSActive,\n           WTSConnected,\n           WTSConnectQuery,\n           WTSShadow,\n           WTSDisconnected,\n           WTSIdle,\n           WTSListen,\n           WTSReset,\n           WTSDown,\n           WTSInit\n       }\n\n       [StructLayout(LayoutKind.Sequential)]\n       private struct PROCESS_INFORMATION\n       {\n           public IntPtr hProcess;\n           public IntPtr hThread;\n           public uint dwProcessId;\n           public uint dwThreadId;\n       }\n\n       private enum SECURITY_IMPERSONATION_LEVEL\n       {\n           SecurityAnonymous = 0,\n           SecurityIdentification = 1,\n           SecurityImpersonation = 2,\n           SecurityDelegation = 3,\n       }\n\n       [StructLayout(LayoutKind.Sequential)]\n       private struct STARTUPINFO\n       {\n           public int cb;\n           public String lpReserved;\n           public String lpDesktop;\n           public String lpTitle;\n           public uint dwX;\n           public uint dwY;\n           public uint dwXSize;\n           public uint dwYSize;\n           public uint dwXCountChars;\n           public uint dwYCountChars;\n           public uint dwFillAttribute;\n           public uint dwFlags;\n           public short wShowWindow;\n           public short cbReserved2;\n           public IntPtr lpReserved2;\n           public IntPtr hStdInput;\n           public IntPtr hStdOutput;\n           public IntPtr hStdError;\n       }\n\n       private enum TOKEN_TYPE\n       {\n           TokenPrimary = 1,\n           TokenImpersonation = 2\n       }\n\n       [StructLayout(LayoutKind.Sequential)]\n       private struct WTS_SESSION_INFO\n       {\n           public readonly UInt32 SessionID;\n\n           [MarshalAs(UnmanagedType.LPStr)]\n           public readonly String pWinStationName;\n\n           public readonly WTS_CONNECTSTATE_CLASS State;\n       }\n\n       #endregion\n\n       // Gets the user token from the currently active session\n       private static bool GetSessionUserToken(ref IntPtr phUserToken)\n       {\n           var bResult = false;\n           var hImpersonationToken = IntPtr.Zero;\n           var activeSessionId = INVALID_SESSION_ID;\n           var pSessionInfo = IntPtr.Zero;\n           var sessionCount = 0;\n\n           // Get a handle to the user access token for the current active session.\n           if (WTSEnumerateSessions(WTS_CURRENT_SERVER_HANDLE, 0, 1, ref pSessionInfo, ref sessionCount) != 0)\n           {\n               var arrayElementSize = Marshal.SizeOf(typeof(WTS_SESSION_INFO));\n               var current = pSessionInfo;\n\n               for (var i = 0; i < sessionCount; i++)\n               {\n                   var si = (WTS_SESSION_INFO)Marshal.PtrToStructure((IntPtr)current, typeof(WTS_SESSION_INFO));\n                   current += arrayElementSize;\n\n                   if (si.State == WTS_CONNECTSTATE_CLASS.WTSActive)\n                   {\n                       activeSessionId = si.SessionID;\n                   }\n               }\n           }\n\n           // If enumerating did not work, fall back to the old method\n           if (activeSessionId == INVALID_SESSION_ID)\n           {\n               activeSessionId = WTSGetActiveConsoleSessionId();\n           }\n\n           if (WTSQueryUserToken(activeSessionId, ref hImpersonationToken) != 0)\n           {\n               // Convert the impersonation token to a primary token\n               bResult = DuplicateTokenEx(hImpersonationToken, 0, IntPtr.Zero,\n                   (int)SECURITY_IMPERSONATION_LEVEL.SecurityImpersonation, (int)TOKEN_TYPE.TokenPrimary,\n                   ref phUserToken);\n\n               CloseHandle(hImpersonationToken);\n           }\n\n           return bResult;\n       }\n\n       public static bool StartProcessAsCurrentUser(string appPath, string cmdLine = null, string workDir = null, bool visible = true)\n       {\n           var hUserToken = IntPtr.Zero;\n           var startInfo = new STARTUPINFO();\n           var procInfo = new PROCESS_INFORMATION();\n           var pEnv = IntPtr.Zero;\n           int iResultOfCreateProcessAsUser;\n\n           startInfo.cb = Marshal.SizeOf(typeof(STARTUPINFO));\n\n           try\n           {\n               if (!GetSessionUserToken(ref hUserToken))\n               {\n                   throw new Exception(\"StartProcessAsCurrentUser: GetSessionUserToken failed.\");\n               }\n\n               uint dwCreationFlags = CREATE_UNICODE_ENVIRONMENT | (uint)(visible ? CREATE_NEW_CONSOLE : CREATE_NO_WINDOW);\n               startInfo.wShowWindow = (short)(visible ? SW.SW_SHOW : SW.SW_HIDE);\n               startInfo.lpDesktop = \"winsta0\\\\default\";\n\n               if (!CreateEnvironmentBlock(ref pEnv, hUserToken, false))\n               {\n                   throw new Exception(\"StartProcessAsCurrentUser: CreateEnvironmentBlock failed.\");\n               }\n\n               if (!CreateProcessAsUser(hUserToken,\n                   appPath, // Application Name\n                   cmdLine, // Command Line\n                   IntPtr.Zero,\n                   IntPtr.Zero,\n                   false,\n                   dwCreationFlags,\n                   pEnv,\n                   workDir, // Working directory\n                   ref startInfo,\n                   out procInfo))\n               {\n                   throw new Exception(\"StartProcessAsCurrentUser: CreateProcessAsUser failed.\\n\");\n               }\n\n               iResultOfCreateProcessAsUser = Marshal.GetLastWin32Error();\n           }\n           finally\n           {\n               CloseHandle(hUserToken);\n               if (pEnv != IntPtr.Zero)\n               {\n                   DestroyEnvironmentBlock(pEnv);\n               }\n               CloseHandle(procInfo.hThread);\n               CloseHandle(procInfo.hProcess);\n           }\n           return true;\n       }\n   }\n}\n\n\n'@\n\nAdd-Type -ReferencedAssemblies 'System', 'System.Runtime.InteropServices' -TypeDefinition $Source -Language CSharp\n$ApplicationPath = 'C:\\Windows\\system32\\WindowsPowerShell\\v1.0\\powershell.exe'\n\n$bytes = [System.Text.Encoding]::Unicode.GetBytes($command)\n$encodedCommand = [Convert]::ToBase64String($bytes)\n$Arguments = '-NoLogo -NonInteractive -ExecutionPolicy ByPass -WindowStyle Hidden -encodedCommand ' + $encodedCommand\n[murrayju.ProcessExtensions.ProcessExtensions]::StartProcessAsCurrentUser($ApplicationPath, $Arguments)",
    "link": "https://github.com/TheJumpCloud/support/blob/master/PowerShell/JumpCloud%20Commands%20Gallery/Windows%20Commands/Windows%20-%20Install%20JumpCloud%20Password%20Manager%20App.md",
    "description": "This command will download and install the JumpCloud Password Manager app to the device if it isn't already installed. On slower networks, timeouts with exit code 127 can occur. Manually setting the default timeout limit to 600 seconds may be advisable."
  },
  {
    "name": "Windows - Install Sentinel One Agent| v1.0 JCCG",
    "type": "windows",
    "command": "$siteToken=\"YOURTOKEN\"\n$installerURL=\"https://path/to/url.exe\"\n\n############### Do Not Edit Below This Line ###############\n\n$installerTempLocation=\"C:\\Windows\\Temp\\SentinelOneAgentInstaller.exe\"\n\nif (Get-Service \"SentinelOneService\" -ErrorAction SilentlyContinue) {\n    Write-Host \"Sentinel One Agent already installed, nothing to do.\"\n    exit 0\n}\nWrite-Host \"Sentinel One Agent not installed.\"\n\nWrite-Host \"Downloading Sentinel One Agent installer now.\"\ntry {\n    Invoke-WebRequest -Uri $installerURL -OutFile $installerTempLocation\n}\ncatch {\n    Write-Error \"Unable to download Sentinel One Agent installer.\"\n    exit 1\n}\nWrite-Host \"Finished downloading Sentinel One Agent installer.\"\n\nWrite-Host \"Installing Sentinel One Agent now, this may take a few minutes.\"\ntry {\n    .\"$installerTempLocation\" --dont_fail_on_config_preserving_failures -t $siteToken\n}\ncatch {\n    Write-Error \"Failed to run Sentinel One Agent installer.\"\n    exit 1\n}\nWrite-Host \"Sentinel One Agent installer returned $($installerProcess.ExitCode).\"\n\nexit $installerProcess.ExitCode",
    "link": "https://github.com/TheJumpCloud/support/blob/master/PowerShell/JumpCloud%20Commands%20Gallery/Windows%20Commands/Windows%20-%20Install%20Sentinel%20One%20Agent.md",
    "description": "This command will download and install the Sentinel One Agent to the device if it isn't already installed.\n\nIn order to use this command:\n\n1. Download the Sentinel One Agent installer and host it at a URL that your devices can access.\n2. Edit the first two lines of the script to include your Customer ID (with checksum value) and the URL where you are hosting the installer.\n3. Extend the command timeout to a value that makes sense in your environment. The suggested command timeout for an environment with average network speeds on devices with average computing power is 10 minutes. Note that the command may timeout with a 124 error code in the command result window if not extended, but the script will continue to run."
  },
  {
    "name": "Windows - List All Users | v1.0 JCCG",
    "type": "windows",
    "command": "$UserAccounts = Get-WmiObject -Class Win32_UserAccount -Filter {LocalAccount = \"True\"} | select Name, Disabled \n\nWrite-Output $UserAccounts",
    "link": "https://github.com/TheJumpCloud/support/blob/master/PowerShell/JumpCloud%20Commands%20Gallery/Windows%20Commands/Windows%20-%20List%20All%20Users.md",
    "description": "Lists all user accounts on a Windows system and shows if the account is enabled or disabled"
  },
  {
    "name": "Windows - Rename System HostName from JumpCloud | v2.0 JCCG",
    "type": "windows",
    "command": "################################################################################\n# This script will update the system hostname to\n# match the value of this systems displayName in the JumpCloud console.\n# An API Key with read access is required to run this script.\n################################################################################\n\n# Set Read API KEY - Required to read \"DisplayName\" from console.jumpcloud.com\n$JCApiKey = \"YourReadOnlyAPIKey\"\n\n# ------- Do not modify below this line ------\n$config = get-content 'C:\\Program Files\\JumpCloud\\Plugins\\Contrib\\jcagent.conf'\n$regex = 'systemKey\\\":\\\"(\\w+)\\\"'\n$systemKey = [regex]::Match($config, $regex).Groups[1].Value\n$headers = @{\n    Accept      = \"application/json\"\n    'x-api-key' = $JCApiKey\n    ContentType = 'application/json'\n}\ntry {\n    $content = Invoke-RestMethod -Method GET -Uri \"https://console.jumpcloud.com/api/systems/$($systemKey)\" -ContentType 'application/json' -Headers $headers -UseBasicParsing\n}\ncatch [System.Net.WebException] {\n    Write-Host \"Caught Web Exception\"\n    try {\n        $content = Invoke-WebRequest -Method GET -Uri \"https://console.jumpcloud.com/api/systems/$($systemKey)\" -ContentType 'application/json' -Headers $headers -UseBasicParsing\n        Write-Host \"Resolving: Https://console.jumpcloud.com\"\n        Write-Host \"StatusCode: $($content.statusCode)\"\n        $content = $content.Content | ConvertFrom-Json\n    }\n    catch {\n        \"Could Not Resolve\"\n        exit 1\n    }\n}\n$oldName = hostname\n$newName = $($content.DisplayName)\nif ($newName -ne $oldName) {\n    Write-Host \"New Hostname Found: $($content.DisplayName)\"\n    Rename-Computer -NewName $newName -Force\n    Write-Host \"$oldName was renamed to $newName\"\n    Write-Host \"The changes will take effect after you restart the computer\"\n}\nif ([System.String]::IsNullOrEmpty($newName)) {\n    Write-Host \"Could not find hostname from JumpCloud Console\"\n    exit 1\n}",
    "link": "https://github.com/TheJumpCloud/support/blob/master/PowerShell/JumpCloud%20Commands%20Gallery/Windows%20Commands/Windows%20-%20Rename%20System%20HostName%20from%20JumpCloud.md",
    "description": "This script uses a read only API key to gather info about the current system. Using Regex, the code filters out the displayName of a given system and sets the system HostName to the name set in the JumpCloud console.\n\nPlease note, there are specific rules for the hostname value. Hostnames must:\n\n- Be a maximum 63 characters in length\n- Contain no whitespace characters or periods\n- Contain only alphanumeric characters and hyphens '-'\n- Hostnames longer than 15 characters will result in a truncated NetBIOS name"
  },
  {
    "name": "Windows - Run As Signed In User Template | v1.1 JCCG",
    "type": "windows",
    "command": "# If Nuget is not installed, go ahead and install it\n[Net.ServicePointManager]::SecurityProtocol = [Net.SecurityProtocolType]::Tls12\n$PkgProvider = Get-PackageProvider\nIf (\"Nuget\" -notin $PkgProvider.Name){\n    Install-PackageProvider -Name NuGet -Force\n}\n\n# If PSModule RunAsUser is not installed, install it\nif ( -not (get-installedModule \"RunAsUser\" -ErrorAction SilentlyContinue)) {\n    install-module RunAsUser -force\n}\n\n$Command = {\n    #Powershell Command Goes Here.\n}\n\ninvoke-ascurrentuser -scriptblock $Command",
    "link": "https://github.com/TheJumpCloud/support/blob/master/PowerShell/JumpCloud%20Commands%20Gallery/Windows%20Commands/Windows%20-%20Run%20As%20Signed%20In%20User%20Template.md",
    "description": "This template can be modified to target a command to run as the signed in user context of a system. The Jumpcloud agent cmd runner executes as NTAuthority\\System and therefore can not interact with the signed in user session on a computer. This template and accompanying Powershell Module code from https://github.com/KelvinTegelaar/RunAsUser allows the Command block to be run as the signed in user session.\n\nBefore running this command the **$Command** block must be populated.\n\nAn example of this command is if `C:\\windows\\system32\\notepad.exe` is placed in the command block and executed against a system that has a signed in user session. Notepad will launch and show up for the signed in user. This will also work if the session is locked but still signed in. It however can only work when there is one signed in session like on most workstation SKU's of Windows."
  },
  {
    "name": "Windows - Send Notification Message | JCCG v1.0",
    "type": "windows",
    "command": "# Enter the notification message\n# Enter the message within the \"\" of $Notification=\"\"\n\n$Notification=\"\"\n\n# ------- Do not modify below this line ------\n\nInvoke-WmiMethod -Path Win32_Process -Name Create -ArgumentList \"msg * $Notification\"",
    "link": "https://github.com/TheJumpCloud/support/blob/master/PowerShell/JumpCloud%20Commands%20Gallery/Windows%20Commands/Windows%20-%20Send%20Notification%20Message.md",
    "description": "Administrators that wish to send notification messages to the current logged in user of the target Windows machines can use this command. \n\nTo use this command enter the text to display through the notification in the $Notification=\"\" variable.\n\nExample: $Notification=\"Fire drill at 10 am on Monday\"\n\n![Example Notification](https://github.com/TheJumpCloud/support/blob/master/PowerShell/JumpCloud%20Commands%20Gallery/Files/Windows%20notification.png?raw=true)"
  },
  {
    "name": "Windows - Set Agent Log Level to Debug | v1.0 JCCG",
    "type": "windows",
    "command": "$loglevel = \"DEBUG\"\n#Find jcagent install path\n$configfiledefault = (Get-ItemProperty -Path 'Registry::HKEY_LOCAL_MACHINE\\SOFTWARE\\JumpCloud\\JumpCloud Agent\\ConfigFile\\').'(default)'\n$index = ($configfiledefault).IndexOf(\"Plugins\")\n$jcinstallpath = $configfiledefault.Substring(0,$index)\n#Remove loglevel.cache if exists\nRemove-Item $jcinstallpath'Loglevel.cache' -ea ig\n#add debug or trace to file\nNew-Item -Path $jcinstallpath -Name Loglevel.cache -ItemType \"file\" -Value $loglevel\n\n#Schedules JumpCloud Agent Restart\nif ( -not (Test-Path -path \"C:\\Windows\\Temp\\JC_ScheduledTasks\"))\n{\n    New-Item -Path \"C:\\Windows\\Temp\\JC_ScheduledTasks\" -ItemType directory\n}\n\n#Creates Agent restart script file\n$FileDate = (get-date -f yyyy-MM-dd-hh-mm)\n$FileName = \"JC_ScheduledWAgentRestart$FileDate.ps1\"\n$TaskName = \"JC_ScheduledWAgentRestart$FileDate\"\n$FilePath = \"C:\\Windows\\Temp\\JC_ScheduledTasks\\\"\n$FileContents = @\"\n    Stop-Service jumpcloud-agent -force\n    Copy-Item -Path \"C:\\Windows\\Temp\\jcagent.log\" -Destination \"C:\\Windows\\Temp\\jcagent_$FileDate.log\"\n    Start-Sleep -Seconds 1\n    Start-Service jumpcloud-agent\n    SCHTASKS /Delete /tn \"$TaskName\" /F\n    #Remove-Item -LiteralPath `$MyInvocation.MyCommand.Path -Force\n\"@\nNew-Item -Path $FilePath -Name $FileName  -ItemType \"file\" -Value $FileContents\n\n#Schedules task to run in 60s\n$RunTime = (Get-Date).AddSeconds(60) | Get-Date -UFormat %R\nSCHTASKS /create /tn \"$TaskName\" /tr \"powershell.exe -noprofile -executionpolicy Unrestricted -file $FilePath$FileName\" /sc ONCE /st $RunTime /RU \"NT AUTHORITY\\SYSTEM\"",
    "link": "https://github.com/TheJumpCloud/support/blob/master/PowerShell/JumpCloud%20Commands%20Gallery/Windows%20Commands/Windows%20-%20Set%20Agent%20Log%20Level%20to%20Debug.md",
    "description": "This command will set the JumpCloud Agent Log Level to Debug. The Agent Log Level can also be set to Trace by changing the `$loglevel` variable from \"DEBUG\" to \"TRACE\". After the command is run, a scheduled task triggers a second script that sets restarts the JumpCloud Agent and removes the itself."
  },
  {
    "name": "Windows - Set Agent Log Level to Default | v1.0 JCCG",
    "type": "windows",
    "command": "#Find jcagent install path\n$configfiledefault = (Get-ItemProperty -Path 'Registry::HKEY_LOCAL_MACHINE\\SOFTWARE\\JumpCloud\\JumpCloud Agent\\ConfigFile\\').'(default)'\n$index = ($configfiledefault).IndexOf(\"Plugins\")\n$jcinstallpath = $configfiledefault.Substring(0,$index)\n#Remove loglevel.cache if exists\nRemove-Item $jcinstallpath'Loglevel.cache' -ea ig\n\n#Schedules JumpCloud Agent Restart\nif ( -not (Test-Path -path \"C:\\Windows\\Temp\\JC_ScheduledTasks\"))\n{\n    New-Item -Path \"C:\\Windows\\Temp\\JC_ScheduledTasks\" -ItemType directory\n}\n\n#Creates Agent restart script file\n$FileDate = (get-date -f yyyy-MM-dd-hh-mm)\n$FileName = \"JC_ScheduledWAgentRestart$FileDate.ps1\"\n$TaskName = \"JC_ScheduledWAgentRestart$FileDate\"\n$FilePath = \"C:\\Windows\\Temp\\JC_ScheduledTasks\\\"\n$FileContents = @\"\n    Stop-Service jumpcloud-agent -force\n    Copy-Item -Path \"C:\\Windows\\Temp\\jcagent.log\" -Destination \"C:\\Windows\\Temp\\jcagent_$FileDate.log\"\n    Start-Sleep -Seconds 1\n    Start-Service jumpcloud-agent\n    SCHTASKS /Delete /tn \"$TaskName\" /F\n    #Remove-Item -LiteralPath `$MyInvocation.MyCommand.Path -Force\n\"@\nNew-Item -Path $FilePath -Name $FileName  -ItemType \"file\" -Value $FileContents\n\n#Schedules task to run in 60s\n$RunTime = (Get-Date).AddSeconds(60) | Get-Date -UFormat %R\nSCHTASKS /create /tn \"$TaskName\" /tr \"powershell.exe -noprofile -executionpolicy Unrestricted -file $FilePath$FileName\" /sc ONCE /st $RunTime /RU \"NT AUTHORITY\\SYSTEM\"",
    "link": "https://github.com/TheJumpCloud/support/blob/master/PowerShell/JumpCloud%20Commands%20Gallery/Windows%20Commands/Windows%20-%20Set%20Agent%20Log%20Level%20to%20Default.md",
    "description": "This command will set the JumpCloud Agent Log Level to Default. After the command is run, a scheduled task triggers a second script that sets restarts the JumpCloud Agent and removes the itself."
  },
  {
    "name": "Windows - Software Restriction Policy | v1.0 JCCG",
    "type": "windows",
    "command": "$RestrictedDirectory = @(\"%UserProfile%\\Downloads\\\", \"C:\\Windows\\Temp\\\")\n$ExecutableTypes = @(\"ADE\",\"ADP\",\"BAS\",\"BAT\",\"CHM\",\"CMD\",\"COM\",\"CPL\",\"CRT\",\"EXE\",\"HLP\",\"HTA\",\"INF\",\"INS\",\"ISP\",\"LNK\",\"MDB\",\"MDE\",\"MSC\",\"MSI\",\"MSP\",\"MST\",\"OCX\",\"PCD\",\"PIF\",\"REG\",\"SCR\",\"SHS\",\"URL\",\"VB\",\"WSC\")\n\nif((Test-Path -LiteralPath \"HKLM:\\SOFTWARE\\Policies\\Microsoft\\Windows\\safer\") -eq $true) {Remove-Item \"HKLM:\\SOFTWARE\\Policies\\Microsoft\\Windows\\safer\" -Recurse};\nNew-Item \"HKLM:\\SOFTWARE\\Policies\\Microsoft\\Windows\\safer\";\nNew-Item \"HKLM:\\SOFTWARE\\Policies\\Microsoft\\Windows\\safer\\codeidentifiers\";\nNew-Item \"HKLM:\\SOFTWARE\\Policies\\Microsoft\\Windows\\safer\\codeidentifiers\\0\";\nNew-Item \"HKLM:\\SOFTWARE\\Policies\\Microsoft\\Windows\\safer\\codeidentifiers\\0\\Paths\";\nNew-ItemProperty 'HKLM:\\SOFTWARE\\Policies\\Microsoft\\Windows\\safer\\codeidentifiers' -Name 'authenticodeenabled' -Value 0 -PropertyType DWord;\nNew-ItemProperty 'HKLM:\\SOFTWARE\\Policies\\Microsoft\\Windows\\safer\\codeidentifiers' -Name 'DefaultLevel' -Value 262144 -PropertyType DWord;\nNew-ItemProperty 'HKLM:\\SOFTWARE\\Policies\\Microsoft\\Windows\\safer\\codeidentifiers' -Name 'TransparentEnabled' -Value 1 -PropertyType DWord;\nNew-ItemProperty 'HKLM:\\SOFTWARE\\Policies\\Microsoft\\Windows\\safer\\codeidentifiers' -Name 'PolicyScope' -Value 0 -PropertyType DWord;\nNew-ItemProperty 'HKLM:\\SOFTWARE\\Policies\\Microsoft\\Windows\\safer\\codeidentifiers' -Name 'ExecutableTypes' -Value $ExecutableTypes -PropertyType MultiString;\n\nforeach ($Directory in $RestrictedDirectory){\n    $pathguid = [guid]::newguid()\n    $newpathkey = \"HKLM:\\SOFTWARE\\Policies\\Microsoft\\Windows\\safer\\codeidentifiers\\0\\Paths\\{\" + $pathguid + \"}\"\n    if((Test-Path -LiteralPath $newpathkey) -ne $true) {New-Item $newpathkey};\n    New-ItemProperty -LiteralPath $newpathkey -Name 'SaferFlags' -Value 0 -PropertyType DWord;\n    New-ItemProperty -LiteralPath $newpathkey -Name 'ItemData' -Value $Directory -PropertyType ExpandString;\n}",
    "link": "https://github.com/TheJumpCloud/support/blob/master/PowerShell/JumpCloud%20Commands%20Gallery/Windows%20Commands/Windows%20-%20Software%20Restriction%20Policy.md",
    "description": "Adds a software restriction policy to windows. This policy will restrict the execution of any matching file type in the restricted directory."
  },
  {
    "name": "Windows - Start Quick Assist Session | v1.1 JCCG",
    "type": "windows",
    "command": "install-module RunAsUser -force\n$Command = {\n\nC:\\Windows\\System32\\quickassist.exe\n\n}",
    "link": "https://github.com/TheJumpCloud/support/blob/master/PowerShell/JumpCloud%20Commands%20Gallery/Windows%20Commands/Windows%20-%20Start%20Quick%20Assist%20Session.md",
    "description": "Executes 'Windows 10 Quick Assist' application as the currently logged on user. The command will fail if no user is logged in."
  }
]